// Copyright (C) 2019-2020 star.engine at outlook dot com
//
// This file is part of StarEngine
//
// StarEngine is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// StarEngine is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with StarEngine.  If not, see <https://www.gnu.org/licenses/>.

#pragma once
#include <Star/Graphics/SConfig.h>
#include <Star/Graphics/SRenderFormat.h>
#include <Star/Graphics/SRenderFwd.h>

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4251)
#endif

namespace Star {

namespace Graphics {

namespace Render {

struct RECT {
    uint32_t mLeft;
    uint32_t mTop;
    uint32_t mRight;
    uint32_t mBottom;
};

struct DISP_RATIONAL {
    uint32_t mNumerator;
    uint32_t mDenominator;
};

struct DISP_SAMPLE_DESC {
    uint32_t mCount;
    uint32_t mQuality;
};

enum GFX_DRIVER_TYPE : uint32_t {
    GFX_DRIVER_TYPE_UNKNOWN	= 0,
    GFX_DRIVER_TYPE_HARDWARE	= ( GFX_DRIVER_TYPE_UNKNOWN + 1 ) ,
    GFX_DRIVER_TYPE_REFERENCE	= ( GFX_DRIVER_TYPE_HARDWARE + 1 ) ,
    GFX_DRIVER_TYPE_NULL	= ( GFX_DRIVER_TYPE_REFERENCE + 1 ) ,
    GFX_DRIVER_TYPE_SOFTWARE	= ( GFX_DRIVER_TYPE_NULL + 1 ) ,
    GFX_DRIVER_TYPE_WARP	= ( GFX_DRIVER_TYPE_SOFTWARE + 1 )
};

enum GFX_FEATURE_LEVEL : uint32_t {
    GFX_FEATURE_LEVEL_1_0_CORE	= 0x1000,
    GFX_FEATURE_LEVEL_9_1	= 0x9100,
    GFX_FEATURE_LEVEL_9_2	= 0x9200,
    GFX_FEATURE_LEVEL_9_3	= 0x9300,
    GFX_FEATURE_LEVEL_10_0	= 0xa000,
    GFX_FEATURE_LEVEL_10_1	= 0xa100,
    GFX_FEATURE_LEVEL_11_0	= 0xb000,
    GFX_FEATURE_LEVEL_11_1	= 0xb100,
    GFX_FEATURE_LEVEL_12_0	= 0xc000,
    GFX_FEATURE_LEVEL_12_1	= 0xc100
};

enum GFX_PRIMITIVE_TOPOLOGY : uint32_t {
    GFX_PRIMITIVE_TOPOLOGY_UNDEFINED	= 0,
    GFX_PRIMITIVE_TOPOLOGY_POINTLIST	= 1,
    GFX_PRIMITIVE_TOPOLOGY_LINELIST	= 2,
    GFX_PRIMITIVE_TOPOLOGY_LINESTRIP	= 3,
    GFX_PRIMITIVE_TOPOLOGY_TRIANGLELIST	= 4,
    GFX_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP	= 5,
    GFX_PRIMITIVE_TOPOLOGY_LINELIST_ADJ	= 10,
    GFX_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ	= 11,
    GFX_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ	= 12,
    GFX_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ	= 13,
    GFX_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST	= 33,
    GFX_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST	= 34,
    GFX_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST	= 35,
    GFX_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST	= 36,
    GFX_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST	= 37,
    GFX_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST	= 38,
    GFX_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST	= 39,
    GFX_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST	= 40,
    GFX_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST	= 41,
    GFX_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST	= 42,
    GFX_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST	= 43,
    GFX_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST	= 44,
    GFX_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST	= 45,
    GFX_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST	= 46,
    GFX_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST	= 47,
    GFX_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST	= 48,
    GFX_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST	= 49,
    GFX_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST	= 50,
    GFX_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST	= 51,
    GFX_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST	= 52,
    GFX_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST	= 53,
    GFX_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST	= 54,
    GFX_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST	= 55,
    GFX_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST	= 56,
    GFX_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST	= 57,
    GFX_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST	= 58,
    GFX_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST	= 59,
    GFX_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST	= 60,
    GFX_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST	= 61,
    GFX_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST	= 62,
    GFX_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST	= 63,
    GFX_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST	= 64,
};

enum GFX_PRIMITIVE : uint32_t {
    GFX_PRIMITIVE_UNDEFINED	= 0,
    GFX_PRIMITIVE_POINT	= 1,
    GFX_PRIMITIVE_LINE	= 2,
    GFX_PRIMITIVE_TRIANGLE	= 3,
    GFX_PRIMITIVE_LINE_ADJ	= 6,
    GFX_PRIMITIVE_TRIANGLE_ADJ	= 7,
    GFX_PRIMITIVE_1_CONTROL_POINT_PATCH	= 8,
    GFX_PRIMITIVE_2_CONTROL_POINT_PATCH	= 9,
    GFX_PRIMITIVE_3_CONTROL_POINT_PATCH	= 10,
    GFX_PRIMITIVE_4_CONTROL_POINT_PATCH	= 11,
    GFX_PRIMITIVE_5_CONTROL_POINT_PATCH	= 12,
    GFX_PRIMITIVE_6_CONTROL_POINT_PATCH	= 13,
    GFX_PRIMITIVE_7_CONTROL_POINT_PATCH	= 14,
    GFX_PRIMITIVE_8_CONTROL_POINT_PATCH	= 15,
    GFX_PRIMITIVE_9_CONTROL_POINT_PATCH	= 16,
    GFX_PRIMITIVE_10_CONTROL_POINT_PATCH	= 17,
    GFX_PRIMITIVE_11_CONTROL_POINT_PATCH	= 18,
    GFX_PRIMITIVE_12_CONTROL_POINT_PATCH	= 19,
    GFX_PRIMITIVE_13_CONTROL_POINT_PATCH	= 20,
    GFX_PRIMITIVE_14_CONTROL_POINT_PATCH	= 21,
    GFX_PRIMITIVE_15_CONTROL_POINT_PATCH	= 22,
    GFX_PRIMITIVE_16_CONTROL_POINT_PATCH	= 23,
    GFX_PRIMITIVE_17_CONTROL_POINT_PATCH	= 24,
    GFX_PRIMITIVE_18_CONTROL_POINT_PATCH	= 25,
    GFX_PRIMITIVE_19_CONTROL_POINT_PATCH	= 26,
    GFX_PRIMITIVE_20_CONTROL_POINT_PATCH	= 27,
    GFX_PRIMITIVE_21_CONTROL_POINT_PATCH	= 28,
    GFX_PRIMITIVE_22_CONTROL_POINT_PATCH	= 29,
    GFX_PRIMITIVE_23_CONTROL_POINT_PATCH	= 30,
    GFX_PRIMITIVE_24_CONTROL_POINT_PATCH	= 31,
    GFX_PRIMITIVE_25_CONTROL_POINT_PATCH	= 32,
    GFX_PRIMITIVE_26_CONTROL_POINT_PATCH	= 33,
    GFX_PRIMITIVE_27_CONTROL_POINT_PATCH	= 34,
    GFX_PRIMITIVE_28_CONTROL_POINT_PATCH	= 35,
    GFX_PRIMITIVE_29_CONTROL_POINT_PATCH	= 36,
    GFX_PRIMITIVE_30_CONTROL_POINT_PATCH	= 37,
    GFX_PRIMITIVE_31_CONTROL_POINT_PATCH	= 38,
    GFX_PRIMITIVE_32_CONTROL_POINT_PATCH	= 39,
};

enum GFX_SRV_DIMENSION : uint32_t {
    GFX_SRV_DIMENSION_UNKNOWN	= 0,
    GFX_SRV_DIMENSION_BUFFER	= 1,
    GFX_SRV_DIMENSION_TEXTURE1D	= 2,
    GFX_SRV_DIMENSION_TEXTURE1DARRAY	= 3,
    GFX_SRV_DIMENSION_TEXTURE2D	= 4,
    GFX_SRV_DIMENSION_TEXTURE2DARRAY	= 5,
    GFX_SRV_DIMENSION_TEXTURE2DMS	= 6,
    GFX_SRV_DIMENSION_TEXTURE2DMSARRAY	= 7,
    GFX_SRV_DIMENSION_TEXTURE3D	= 8,
    GFX_SRV_DIMENSION_TEXTURECUBE	= 9,
    GFX_SRV_DIMENSION_TEXTURECUBEARRAY	= 10,
    GFX_SRV_DIMENSION_BUFFEREX	= 11,
};

enum GFX_NAME : uint32_t {
    GFX_NAME_UNDEFINED	= 0,
    GFX_NAME_POSITION	= 1,
    GFX_NAME_CLIP_DISTANCE	= 2,
    GFX_NAME_CULL_DISTANCE	= 3,
    GFX_NAME_RENDER_TARGET_ARRAY_INDEX	= 4,
    GFX_NAME_VIEWPORT_ARRAY_INDEX	= 5,
    GFX_NAME_VERTEX_ID	= 6,
    GFX_NAME_PRIMITIVE_ID	= 7,
    GFX_NAME_INSTANCE_ID	= 8,
    GFX_NAME_IS_FRONT_FACE	= 9,
    GFX_NAME_SAMPLE_INDEX	= 10,
    GFX_NAME_FINAL_QUAD_EDGE_TESSFACTOR	= 11,
    GFX_NAME_FINAL_QUAD_INSIDE_TESSFACTOR	= 12,
    GFX_NAME_FINAL_TRI_EDGE_TESSFACTOR	= 13,
    GFX_NAME_FINAL_TRI_INSIDE_TESSFACTOR	= 14,
    GFX_NAME_FINAL_LINE_DETAIL_TESSFACTOR	= 15,
    GFX_NAME_FINAL_LINE_DENSITY_TESSFACTOR	= 16,
    GFX_NAME_BARYCENTRICS	= 23,
    GFX_NAME_SHADINGRATE	= 24,
    GFX_NAME_TARGET	= 64,
    GFX_NAME_DEPTH	= 65,
    GFX_NAME_COVERAGE	= 66,
    GFX_NAME_DEPTH_GREATER_EQUAL	= 67,
    GFX_NAME_DEPTH_LESS_EQUAL	= 68,
    GFX_NAME_STENCIL_REF	= 69,
    GFX_NAME_INNER_COVERAGE	= 70,
    NAME_BARYCENTRICS	= GFX_NAME_BARYCENTRICS,
    NAME_SHADINGRATE	= GFX_NAME_SHADINGRATE
};

enum GFX_RESOURCE_RETURN_TYPE : uint32_t {
    GFX_RETURN_TYPE_UNORM	= 1,
    GFX_RETURN_TYPE_SNORM	= 2,
    GFX_RETURN_TYPE_SINT	= 3,
    GFX_RETURN_TYPE_UINT	= 4,
    GFX_RETURN_TYPE_FLOAT	= 5,
    GFX_RETURN_TYPE_MIXED	= 6,
    GFX_RETURN_TYPE_DOUBLE	= 7,
    GFX_RETURN_TYPE_CONTINUED	= 8,
};

enum GFX_REGISTER_COMPONENT_TYPE : uint32_t {
    GFX_REGISTER_COMPONENT_UNKNOWN	= 0,
    GFX_REGISTER_COMPONENT_UINT32	= 1,
    GFX_REGISTER_COMPONENT_SINT32	= 2,
    GFX_REGISTER_COMPONENT_FLOAT32	= 3,
};

enum GFX_TESSELLATOR_DOMAIN : uint32_t {
    GFX_TESSELLATOR_DOMAIN_UNDEFINED	= 0,
    GFX_TESSELLATOR_DOMAIN_ISOLINE	= 1,
    GFX_TESSELLATOR_DOMAIN_TRI	= 2,
    GFX_TESSELLATOR_DOMAIN_QUAD	= 3,
};

enum GFX_TESSELLATOR_PARTITIONING : uint32_t {
    GFX_TESSELLATOR_PARTITIONING_UNDEFINED	= 0,
    GFX_TESSELLATOR_PARTITIONING_INTEGER	= 1,
    GFX_TESSELLATOR_PARTITIONING_POW2	= 2,
    GFX_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD	= 3,
    GFX_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN	= 4,
};

enum GFX_TESSELLATOR_OUTPUT_PRIMITIVE : uint32_t {
    GFX_TESSELLATOR_OUTPUT_UNDEFINED	= 0,
    GFX_TESSELLATOR_OUTPUT_POINT	= 1,
    GFX_TESSELLATOR_OUTPUT_LINE	= 2,
    GFX_TESSELLATOR_OUTPUT_TRIANGLE_CW	= 3,
    GFX_TESSELLATOR_OUTPUT_TRIANGLE_CCW	= 4,
};

enum GFX_MIN_PRECISION : uint32_t {
    GFX_MIN_PRECISION_DEFAULT	= 0,
    GFX_MIN_PRECISION_FLOAT_16	= 1,
    GFX_MIN_PRECISION_FLOAT_2_8	= 2,
    GFX_MIN_PRECISION_RESERVED	= 3,
    GFX_MIN_PRECISION_SINT_16	= 4,
    GFX_MIN_PRECISION_UINT_16	= 5,
    GFX_MIN_PRECISION_ANY_16	= 0xf0,
    GFX_MIN_PRECISION_ANY_10	= 0xf1
};

enum GFX_INTERPOLATION_MODE : uint32_t {
    GFX_INTERPOLATION_UNDEFINED	= 0,
    GFX_INTERPOLATION_CONSTANT	= 1,
    GFX_INTERPOLATION_LINEAR	= 2,
    GFX_INTERPOLATION_LINEAR_CENTROID	= 3,
    GFX_INTERPOLATION_LINEAR_NOPERSPECTIVE	= 4,
    GFX_INTERPOLATION_LINEAR_NOPERSPECTIVE_CENTROID	= 5,
    GFX_INTERPOLATION_LINEAR_SAMPLE	= 6,
    GFX_INTERPOLATION_LINEAR_NOPERSPECTIVE_SAMPLE	= 7
};

enum COMMAND_LIST_TYPE : uint32_t {
    COMMAND_LIST_TYPE_DIRECT	= 0,
    COMMAND_LIST_TYPE_BUNDLE	= 1,
    COMMAND_LIST_TYPE_COMPUTE	= 2,
    COMMAND_LIST_TYPE_COPY	= 3,
    COMMAND_LIST_TYPE_VIDEO_DECODE	= 4,
    COMMAND_LIST_TYPE_VIDEO_PROCESS	= 5,
    COMMAND_LIST_TYPE_VIDEO_ENCODE	= 6
};

enum COMMAND_QUEUE_FLAGS : uint32_t {
    COMMAND_QUEUE_FLAG_NONE	= 0,
    COMMAND_QUEUE_FLAG_DISABLE_GPU_TIMEOUT	= 0x1
};

enum COMMAND_QUEUE_PRIORITY : uint32_t {
    COMMAND_QUEUE_PRIORITY_NORMAL	= 0,
    COMMAND_QUEUE_PRIORITY_HIGH	= 100,
    COMMAND_QUEUE_PRIORITY_GLOBAL_REALTIME	= 10000
};

struct COMMAND_QUEUE_DESC {
    COMMAND_LIST_TYPE mType;
    int32_t mPriority;
    COMMAND_QUEUE_FLAGS mFlags;
    uint32_t mNodeMask;
};

enum PRIMITIVE_TOPOLOGY_TYPE : uint32_t {
    PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED	= 0,
    PRIMITIVE_TOPOLOGY_TYPE_POINT	= 1,
    PRIMITIVE_TOPOLOGY_TYPE_LINE	= 2,
    PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE	= 3,
    PRIMITIVE_TOPOLOGY_TYPE_PATCH	= 4
};

enum INPUT_CLASSIFICATION : uint32_t {
    INPUT_CLASSIFICATION_PER_VERTEX_DATA	= 0,
    INPUT_CLASSIFICATION_PER_INSTANCE_DATA	= 1
};

struct INPUT_ELEMENT_DESC {
    const char* mSemanticName;
    uint32_t mSemanticIndex;
    Format mFormat;
    uint32_t mInputSlot;
    uint32_t mAlignedByteOffset;
    INPUT_CLASSIFICATION mInputSlotClass;
    uint32_t mInstanceDataStepRate;
};

enum FILL_MODE : uint32_t {
    FILL_MODE_WIREFRAME	= 2,
    FILL_MODE_SOLID	= 3
};

enum CULL_MODE : uint32_t {
    CULL_MODE_NONE	= 1,
    CULL_MODE_FRONT	= 2,
    CULL_MODE_BACK	= 3
};

struct SO_DECLARATION_ENTRY {
    uint32_t mStream;
    const char* mSemanticName;
    uint32_t mSemanticIndex;
    uint8_t mStartComponent;
    uint8_t mComponentCount;
    uint8_t mOutputSlot;
};

struct VIEWPORT {
    float mTopLeftX;
    float mTopLeftY;
    float mWidth;
    float mHeight;
    float mMinDepth;
    float mMaxDepth;
};

struct BOX {
    uint32_t mleft;
    uint32_t mtop;
    uint32_t mfront;
    uint32_t mright;
    uint32_t mbottom;
    uint32_t mback;
};

enum COMPARISON_FUNC : uint32_t {
    COMPARISON_FUNC_NEVER	= 1,
    COMPARISON_FUNC_LESS	= 2,
    COMPARISON_FUNC_EQUAL	= 3,
    COMPARISON_FUNC_LESS_EQUAL	= 4,
    COMPARISON_FUNC_GREATER	= 5,
    COMPARISON_FUNC_NOT_EQUAL	= 6,
    COMPARISON_FUNC_GREATER_EQUAL	= 7,
    COMPARISON_FUNC_ALWAYS	= 8
};

enum DEPTH_WRITE_MASK : uint32_t {
    DEPTH_WRITE_MASK_ZERO	= 0,
    DEPTH_WRITE_MASK_ALL	= 1
};

enum STENCIL_OP : uint32_t {
    STENCIL_OP_KEEP	= 1,
    STENCIL_OP_ZERO	= 2,
    STENCIL_OP_REPLACE	= 3,
    STENCIL_OP_INCR_SAT	= 4,
    STENCIL_OP_DECR_SAT	= 5,
    STENCIL_OP_INVERT	= 6,
    STENCIL_OP_INCR	= 7,
    STENCIL_OP_DECR	= 8
};

struct DEPTH_STENCILOP_DESC {
    STENCIL_OP mStencilFailOp;
    STENCIL_OP mStencilDepthFailOp;
    STENCIL_OP mStencilPassOp;
    COMPARISON_FUNC mStencilFunc;
};

struct DEPTH_STENCIL_DESC {
    Bool mDepthEnable;
    DEPTH_WRITE_MASK mDepthWriteMask;
    COMPARISON_FUNC mDepthFunc;
    Bool mStencilEnable;
    uint8_t mStencilReadMask;
    uint8_t mStencilWriteMask;
    DEPTH_STENCILOP_DESC mFrontFace;
    DEPTH_STENCILOP_DESC mBackFace;
};

struct DEPTH_STENCIL_DESC1 {
    Bool mDepthEnable;
    DEPTH_WRITE_MASK mDepthWriteMask;
    COMPARISON_FUNC mDepthFunc;
    Bool mStencilEnable;
    uint8_t mStencilReadMask;
    uint8_t mStencilWriteMask;
    DEPTH_STENCILOP_DESC mFrontFace;
    DEPTH_STENCILOP_DESC mBackFace;
    Bool mDepthBoundsTestEnable;
};

enum BLEND : uint32_t {
    BLEND_ZERO	= 1,
    BLEND_ONE	= 2,
    BLEND_SRC_COLOR	= 3,
    BLEND_INV_SRC_COLOR	= 4,
    BLEND_SRC_ALPHA	= 5,
    BLEND_INV_SRC_ALPHA	= 6,
    BLEND_DEST_ALPHA	= 7,
    BLEND_INV_DEST_ALPHA	= 8,
    BLEND_DEST_COLOR	= 9,
    BLEND_INV_DEST_COLOR	= 10,
    BLEND_SRC_ALPHA_SAT	= 11,
    BLEND_BLEND_FACTOR	= 14,
    BLEND_INV_BLEND_FACTOR	= 15,
    BLEND_SRC1_COLOR	= 16,
    BLEND_INV_SRC1_COLOR	= 17,
    BLEND_SRC1_ALPHA	= 18,
    BLEND_INV_SRC1_ALPHA	= 19
};

enum BLEND_OP : uint32_t {
    BLEND_OP_ADD	= 1,
    BLEND_OP_SUBTRACT	= 2,
    BLEND_OP_REV_SUBTRACT	= 3,
    BLEND_OP_MIN	= 4,
    BLEND_OP_MAX	= 5
};

enum COLOR_WRITE_ENABLE : uint32_t {
    COLOR_WRITE_ENABLE_RED	= 1,
    COLOR_WRITE_ENABLE_GREEN	= 2,
    COLOR_WRITE_ENABLE_BLUE	= 4,
    COLOR_WRITE_ENABLE_ALPHA	= 8,
    COLOR_WRITE_ENABLE_ALL	= ( ( ( COLOR_WRITE_ENABLE_RED | COLOR_WRITE_ENABLE_GREEN )  | COLOR_WRITE_ENABLE_BLUE )  | COLOR_WRITE_ENABLE_ALPHA )
};

enum LOGIC_OP : uint32_t {
    LOGIC_OP_CLEAR	= 0,
    LOGIC_OP_SET	= ( LOGIC_OP_CLEAR + 1 ) ,
    LOGIC_OP_COPY	= ( LOGIC_OP_SET + 1 ) ,
    LOGIC_OP_COPY_INVERTED	= ( LOGIC_OP_COPY + 1 ) ,
    LOGIC_OP_NOOP	= ( LOGIC_OP_COPY_INVERTED + 1 ) ,
    LOGIC_OP_INVERT	= ( LOGIC_OP_NOOP + 1 ) ,
    LOGIC_OP_AND	= ( LOGIC_OP_INVERT + 1 ) ,
    LOGIC_OP_NAND	= ( LOGIC_OP_AND + 1 ) ,
    LOGIC_OP_OR	= ( LOGIC_OP_NAND + 1 ) ,
    LOGIC_OP_NOR	= ( LOGIC_OP_OR + 1 ) ,
    LOGIC_OP_XOR	= ( LOGIC_OP_NOR + 1 ) ,
    LOGIC_OP_EQUIV	= ( LOGIC_OP_XOR + 1 ) ,
    LOGIC_OP_AND_REVERSE	= ( LOGIC_OP_EQUIV + 1 ) ,
    LOGIC_OP_AND_INVERTED	= ( LOGIC_OP_AND_REVERSE + 1 ) ,
    LOGIC_OP_OR_REVERSE	= ( LOGIC_OP_AND_INVERTED + 1 ) ,
    LOGIC_OP_OR_INVERTED	= ( LOGIC_OP_OR_REVERSE + 1 )
};

struct RENDER_TARGET_BLEND_DESC {
    Bool mBlendEnable;
    Bool mLogicOpEnable;
    BLEND mSrcBlend;
    BLEND mDestBlend;
    BLEND_OP mBlendOp;
    BLEND mSrcBlendAlpha;
    BLEND mDestBlendAlpha;
    BLEND_OP mBlendOpAlpha;
    LOGIC_OP mLogicOp;
    uint8_t mRenderTargetWriteMask;
};

struct BLEND_DESC {
    Bool mAlphaToCoverageEnable;
    Bool mIndependentBlendEnable;
    RENDER_TARGET_BLEND_DESC mRenderTarget[ 8 ];
};

enum CONSERVATIVE_RASTERIZATION_MODE : uint32_t {
    CONSERVATIVE_RASTERIZATION_MODE_OFF	= 0,
    CONSERVATIVE_RASTERIZATION_MODE_ON	= 1
};

struct RASTERIZER_DESC {
    FILL_MODE mFillMode;
    CULL_MODE mCullMode;
    Bool mFrontCounterClockwise;
    int32_t mDepthBias;
    float mDepthBiasClamp;
    float mSlopeScaledDepthBias;
    Bool mDepthClipEnable;
    Bool mMultisampleEnable;
    Bool mAntialiasedLineEnable;
    uint32_t mForcedSampleCount;
    CONSERVATIVE_RASTERIZATION_MODE mConservativeRaster;
};

struct SHADER_BYTECODE {
    const void *mShaderBytecode;
    size_t mBytecodeLength;
};

struct STREAM_OUTPUT_DESC {
    const SO_DECLARATION_ENTRY *mSODeclaration;
    uint32_t mNumEntries;
    const uint32_t *mBufferStrides;
    uint32_t mNumStrides;
    uint32_t mRasterizedStream;
};

struct INPUT_LAYOUT_DESC {
    const INPUT_ELEMENT_DESC *mInputElementDescs;
    uint32_t mNumElements;
};

enum INDEX_BUFFER_STRIP_CUT_VALUE : uint32_t {
    INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED	= 0,
    INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF	= 1,
    INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF	= 2
};

struct CACHED_PIPELINE_STATE {
    const void *mCachedBlob;
    size_t mCachedBlobSizeInBytes;
};

enum PIPELINE_STATE_FLAGS : uint32_t {
    PIPELINE_STATE_FLAG_NONE	= 0,
    PIPELINE_STATE_FLAG_TOOL_DEBUG	= 0x1
};

struct GRAPHICS_PIPELINE_STATE_DESC {
    void *mRootSignature;
    SHADER_BYTECODE mVS;
    SHADER_BYTECODE mPS;
    SHADER_BYTECODE mDS;
    SHADER_BYTECODE mHS;
    SHADER_BYTECODE mGS;
    STREAM_OUTPUT_DESC mStreamOutput;
    BLEND_DESC mBlendState;
    uint32_t mSampleMask;
    RASTERIZER_DESC mRasterizerState;
    DEPTH_STENCIL_DESC mDepthStencilState;
    INPUT_LAYOUT_DESC mInputLayout;
    INDEX_BUFFER_STRIP_CUT_VALUE mIBStripCutValue;
    PRIMITIVE_TOPOLOGY_TYPE mPrimitiveTopologyType;
    uint32_t mNumRenderTargets;
    Format mRTVFormats[ 8 ];
    Format mDSVFormat;
    DISP_SAMPLE_DESC mSampleDesc;
    uint32_t mNodeMask;
    CACHED_PIPELINE_STATE mCachedPSO;
    PIPELINE_STATE_FLAGS mFlags;
};

struct COMPUTE_PIPELINE_STATE_DESC {
    void *mRootSignature;
    SHADER_BYTECODE mCS;
    uint32_t mNodeMask;
    CACHED_PIPELINE_STATE mCachedPSO;
    PIPELINE_STATE_FLAGS mFlags;
};

struct PIPELINE_STATE_STREAM_DESC {
    size_t mSizeInBytes;
     void *mPipelineStateSubobjectStream;
};

enum PIPELINE_STATE_SUBOBJECT_TYPE : uint32_t {
    PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE	= 0,
    PIPELINE_STATE_SUBOBJECT_TYPE_VS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_PS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_VS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_DS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_PS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_HS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_DS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_GS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_HS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_CS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_GS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT	= ( PIPELINE_STATE_SUBOBJECT_TYPE_CS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_BLEND	= ( PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK	= ( PIPELINE_STATE_SUBOBJECT_TYPE_BLEND + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER	= ( PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL	= ( PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT	= ( PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE	= ( PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY	= ( PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT	= ( PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC	= ( PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK	= ( PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO	= ( PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS	= ( PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1	= ( PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING	= ( PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1 + 1 ) ,
    PIPELINE_STATE_SUBOBJECT_TYPE_MAX_VALID	= ( PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING + 1 )
};

enum FEATURE : uint32_t {
    FEATURE_OPTIONS	= 0,
    FEATURE_ARCHITECTURE	= 1,
    FEATURE_FEATURE_LEVELS	= 2,
    FEATURE_FORMAT_SUPPORT	= 3,
    FEATURE_MULTISAMPLE_QUALITY_LEVELS	= 4,
    FEATURE_FORMAT_INFO	= 5,
    FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT	= 6,
    FEATURE_SHADER_MODEL	= 7,
    FEATURE_OPTIONS1	= 8,
    FEATURE_PROTECTED_RESOURCE_SESSION_SUPPORT	= 10,
    FEATURE_ROOT_SIGNATURE	= 12,
    FEATURE_ARCHITECTURE1	= 16,
    FEATURE_OPTIONS2	= 18,
    FEATURE_SHADER_CACHE	= 19,
    FEATURE_COMMAND_QUEUE_PRIORITY	= 20,
    FEATURE_OPTIONS3	= 21,
    FEATURE_EXISTING_HEAPS	= 22,
    FEATURE_OPTIONS4	= 23,
    FEATURE_SERIALIZATION	= 24,
    FEATURE_CROSS_NODE	= 25,
    FEATURE_OPTIONS5	= 27,
    FEATURE_OPTIONS6	= 30,
    FEATURE_QUERY_META_COMMAND	= 31
};

enum SHADER_MIN_PRECISION_SUPPORT : uint32_t {
    SHADER_MIN_PRECISION_SUPPORT_NONE	= 0,
    SHADER_MIN_PRECISION_SUPPORT_10_BIT	= 0x1,
    SHADER_MIN_PRECISION_SUPPORT_16_BIT	= 0x2
};

enum TILED_RESOURCES_TIER : uint32_t {
    TILED_RESOURCES_TIER_NOT_SUPPORTED	= 0,
    TILED_RESOURCES_TIER_1	= 1,
    TILED_RESOURCES_TIER_2	= 2,
    TILED_RESOURCES_TIER_3	= 3,
    TILED_RESOURCES_TIER_4	= 4
};

enum RESOURCE_BINDING_TIER : uint32_t {
    RESOURCE_BINDING_TIER_1	= 1,
    RESOURCE_BINDING_TIER_2	= 2,
    RESOURCE_BINDING_TIER_3	= 3
};

enum CONSERVATIVE_RASTERIZATION_TIER : uint32_t {
    CONSERVATIVE_RASTERIZATION_TIER_NOT_SUPPORTED	= 0,
    CONSERVATIVE_RASTERIZATION_TIER_1	= 1,
    CONSERVATIVE_RASTERIZATION_TIER_2	= 2,
    CONSERVATIVE_RASTERIZATION_TIER_3	= 3
};

enum FORMAT_SUPPORT1 : uint32_t {
    FORMAT_SUPPORT1_NONE	= 0,
    FORMAT_SUPPORT1_BUFFER	= 0x1,
    FORMAT_SUPPORT1_IA_VERTEX_BUFFER	= 0x2,
    FORMAT_SUPPORT1_IA_INDEX_BUFFER	= 0x4,
    FORMAT_SUPPORT1_SO_BUFFER	= 0x8,
    FORMAT_SUPPORT1_TEXTURE1D	= 0x10,
    FORMAT_SUPPORT1_TEXTURE2D	= 0x20,
    FORMAT_SUPPORT1_TEXTURE3D	= 0x40,
    FORMAT_SUPPORT1_TEXTURECUBE	= 0x80,
    FORMAT_SUPPORT1_SHADER_LOAD	= 0x100,
    FORMAT_SUPPORT1_SHADER_SAMPLE	= 0x200,
    FORMAT_SUPPORT1_SHADER_SAMPLE_COMPARISON	= 0x400,
    FORMAT_SUPPORT1_SHADER_SAMPLE_MONO_TEXT	= 0x800,
    FORMAT_SUPPORT1_MIP	= 0x1000,
    FORMAT_SUPPORT1_RENDER_TARGET	= 0x4000,
    FORMAT_SUPPORT1_BLENDABLE	= 0x8000,
    FORMAT_SUPPORT1_DEPTH_STENCIL	= 0x10000,
    FORMAT_SUPPORT1_MULTISAMPLE_RESOLVE	= 0x40000,
    FORMAT_SUPPORT1_DISPLAY	= 0x80000,
    FORMAT_SUPPORT1_CAST_WITHIN_BIT_LAYOUT	= 0x100000,
    FORMAT_SUPPORT1_MULTISAMPLE_RENDERTARGET	= 0x200000,
    FORMAT_SUPPORT1_MULTISAMPLE_LOAD	= 0x400000,
    FORMAT_SUPPORT1_SHADER_GATHER	= 0x800000,
    FORMAT_SUPPORT1_BACK_BUFFER_CAST	= 0x1000000,
    FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW	= 0x2000000,
    FORMAT_SUPPORT1_SHADER_GATHER_COMPARISON	= 0x4000000,
    FORMAT_SUPPORT1_DECODER_OUTPUT	= 0x8000000,
    FORMAT_SUPPORT1_VIDEO_PROCESSOR_OUTPUT	= 0x10000000,
    FORMAT_SUPPORT1_VIDEO_PROCESSOR_INPUT	= 0x20000000,
    FORMAT_SUPPORT1_VIDEO_ENCODER	= 0x40000000
};

enum FORMAT_SUPPORT2 : uint32_t {
    FORMAT_SUPPORT2_NONE	= 0,
    FORMAT_SUPPORT2_UAV_ATOMIC_ADD	= 0x1,
    FORMAT_SUPPORT2_UAV_ATOMIC_BITWISE_OPS	= 0x2,
    FORMAT_SUPPORT2_UAV_ATOMIC_COMPARE_STORE_OR_COMPARE_EXCHANGE	= 0x4,
    FORMAT_SUPPORT2_UAV_ATOMIC_EXCHANGE	= 0x8,
    FORMAT_SUPPORT2_UAV_ATOMIC_SIGNED_MIN_OR_MAX	= 0x10,
    FORMAT_SUPPORT2_UAV_ATOMIC_UNSIGNED_MIN_OR_MAX	= 0x20,
    FORMAT_SUPPORT2_UAV_TYPED_LOAD	= 0x40,
    FORMAT_SUPPORT2_UAV_TYPED_STORE	= 0x80,
    FORMAT_SUPPORT2_OUTPUT_MERGER_LOGIC_OP	= 0x100,
    FORMAT_SUPPORT2_TILED	= 0x200,
    FORMAT_SUPPORT2_MULTIPLANE_OVERLAY	= 0x4000
};

enum MULTISAMPLE_QUALITY_LEVEL_FLAGS : uint32_t {
    MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE	= 0,
    MULTISAMPLE_QUALITY_LEVELS_FLAG_TILED_RESOURCE	= 0x1
};

enum CROSS_NODE_SHARING_TIER : uint32_t {
    CROSS_NODE_SHARING_TIER_NOT_SUPPORTED	= 0,
    CROSS_NODE_SHARING_TIER_1_EMULATED	= 1,
    CROSS_NODE_SHARING_TIER_1	= 2,
    CROSS_NODE_SHARING_TIER_2	= 3,
    CROSS_NODE_SHARING_TIER_3	= 4
};

enum RESOURCE_HEAP_TIER : uint32_t {
    RESOURCE_HEAP_TIER_1	= 1,
    RESOURCE_HEAP_TIER_2	= 2
};

enum PROGRAMMABLE_SAMPLE_POSITIONS_TIER : uint32_t {
    PROGRAMMABLE_SAMPLE_POSITIONS_TIER_NOT_SUPPORTED	= 0,
    PROGRAMMABLE_SAMPLE_POSITIONS_TIER_1	= 1,
    PROGRAMMABLE_SAMPLE_POSITIONS_TIER_2	= 2
};

enum VIEW_INSTANCING_TIER : uint32_t {
    VIEW_INSTANCING_TIER_NOT_SUPPORTED	= 0,
    VIEW_INSTANCING_TIER_1	= 1,
    VIEW_INSTANCING_TIER_2	= 2,
    VIEW_INSTANCING_TIER_3	= 3
};

struct FEATURE_DATA_D3D12_OPTIONS {
    Bool mDoublePrecisionFloatShaderOps;
    Bool mOutputMergerLogicOp;
    SHADER_MIN_PRECISION_SUPPORT mMinPrecisionSupport;
    TILED_RESOURCES_TIER mTiledResourcesTier;
    RESOURCE_BINDING_TIER mResourceBindingTier;
    Bool mPSSpecifiedStencilRefSupported;
    Bool mTypedUAVLoadAdditionalFormats;
    Bool mROVsSupported;
    CONSERVATIVE_RASTERIZATION_TIER mConservativeRasterizationTier;
    uint32_t mMaxGPUVirtualAddressBitsPerResource;
    Bool mStandardSwizzle64KBSupported;
    CROSS_NODE_SHARING_TIER mCrossNodeSharingTier;
    Bool mCrossAdapterRowMajorTextureSupported;
    Bool mVPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation;
    RESOURCE_HEAP_TIER mResourceHeapTier;
};

struct FEATURE_DATA_D3D12_OPTIONS1 {
    Bool mWaveOps;
    uint32_t mWaveLaneCountMin;
    uint32_t mWaveLaneCountMax;
    uint32_t mTotalLaneCount;
    Bool mExpandedComputeResourceStates;
    Bool mInt64ShaderOps;
};

struct FEATURE_DATA_D3D12_OPTIONS2 {
    Bool mDepthBoundsTestSupported;
    PROGRAMMABLE_SAMPLE_POSITIONS_TIER mProgrammableSamplePositionsTier;
};

enum GFX_ROOT_SIGNATURE_VERSION : uint32_t {
    GFX_ROOT_SIGNATURE_VERSION_1	= 0x1,
    GFX_ROOT_SIGNATURE_VERSION_1_0	= 0x1,
    GFX_ROOT_SIGNATURE_VERSION_1_1	= 0x2
};

struct FEATURE_DATA_ROOT_SIGNATURE {
    GFX_ROOT_SIGNATURE_VERSION mHighestVersion;
};

struct FEATURE_DATA_ARCHITECTURE {
    uint32_t mNodeIndex;
    Bool mTileBasedRenderer;
    Bool mUMA;
    Bool mCacheCoherentUMA;
};

struct FEATURE_DATA_ARCHITECTURE1 {
    uint32_t mNodeIndex;
    Bool mTileBasedRenderer;
    Bool mUMA;
    Bool mCacheCoherentUMA;
    Bool mIsolatedMMU;
};

struct FEATURE_DATA_FEATURE_LEVELS {
    uint32_t mNumFeatureLevels;
    const GFX_FEATURE_LEVEL *mFeatureLevelsRequested;
    GFX_FEATURE_LEVEL mMaxSupportedFeatureLevel;
};

enum GFX_SHADER_MODEL : uint32_t {
    GFX_SHADER_MODEL_5_1	= 0x51,
    GFX_SHADER_MODEL_6_0	= 0x60,
    GFX_SHADER_MODEL_6_1	= 0x61,
    GFX_SHADER_MODEL_6_2	= 0x62,
    GFX_SHADER_MODEL_6_3	= 0x63,
    GFX_SHADER_MODEL_6_4	= 0x64,
    GFX_SHADER_MODEL_6_5	= 0x65
};

struct FEATURE_DATA_SHADER_MODEL {
    GFX_SHADER_MODEL mHighestShaderModel;
};

struct FEATURE_DATA_FORMAT_SUPPORT {
    Format mFormat;
    FORMAT_SUPPORT1 mSupport1;
    FORMAT_SUPPORT2 mSupport2;
};

struct FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    Format mFormat;
    uint32_t mSampleCount;
    MULTISAMPLE_QUALITY_LEVEL_FLAGS mFlags;
    uint32_t mNumQualityLevels;
};

struct FEATURE_DATA_FORMAT_INFO {
    Format mFormat;
    uint8_t mPlaneCount;
};

struct FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    uint32_t mMaxGPUVirtualAddressBitsPerResource;
    uint32_t mMaxGPUVirtualAddressBitsPerProcess;
};

enum SHADER_CACHE_SUPPORT_FLAGS : uint32_t {
    SHADER_CACHE_SUPPORT_NONE	= 0,
    SHADER_CACHE_SUPPORT_SINGLE_PSO	= 0x1,
    SHADER_CACHE_SUPPORT_LIBRARY	= 0x2,
    SHADER_CACHE_SUPPORT_AUTOMATIC_INPROC_CACHE	= 0x4,
    SHADER_CACHE_SUPPORT_AUTOMATIC_DISK_CACHE	= 0x8
};

struct FEATURE_DATA_SHADER_CACHE {
    SHADER_CACHE_SUPPORT_FLAGS mSupportFlags;
};

struct FEATURE_DATA_COMMAND_QUEUE_PRIORITY {
    COMMAND_LIST_TYPE mCommandListType;
    uint32_t mPriority;
    Bool mPriorityForTypeIsSupported;
};

enum COMMAND_LIST_SUPPORT_FLAGS : uint32_t {
    COMMAND_LIST_SUPPORT_FLAG_NONE	= 0,
    COMMAND_LIST_SUPPORT_FLAG_DIRECT	= ( 1 << COMMAND_LIST_TYPE_DIRECT ) ,
    COMMAND_LIST_SUPPORT_FLAG_BUNDLE	= ( 1 << COMMAND_LIST_TYPE_BUNDLE ) ,
    COMMAND_LIST_SUPPORT_FLAG_COMPUTE	= ( 1 << COMMAND_LIST_TYPE_COMPUTE ) ,
    COMMAND_LIST_SUPPORT_FLAG_COPY	= ( 1 << COMMAND_LIST_TYPE_COPY ) ,
    COMMAND_LIST_SUPPORT_FLAG_VIDEO_DECODE	= ( 1 << COMMAND_LIST_TYPE_VIDEO_DECODE ) ,
    COMMAND_LIST_SUPPORT_FLAG_VIDEO_PROCESS	= ( 1 << COMMAND_LIST_TYPE_VIDEO_PROCESS ) ,
    COMMAND_LIST_SUPPORT_FLAG_VIDEO_ENCODE	= ( 1 << COMMAND_LIST_TYPE_VIDEO_ENCODE )
};

struct FEATURE_DATA_D3D12_OPTIONS3 {
    Bool mCopyQueueTimestampQueriesSupported;
    Bool mCastingFullyTypedFormatSupported;
    COMMAND_LIST_SUPPORT_FLAGS mWriteBufferImmediateSupportFlags;
    VIEW_INSTANCING_TIER mViewInstancingTier;
    Bool mBarycentricsSupported;
};

struct FEATURE_DATA_EXISTING_HEAPS {
    Bool mSupported;
};

enum SHARED_RESOURCE_COMPATIBILITY_TIER : uint32_t {
    SHARED_RESOURCE_COMPATIBILITY_TIER_0	= 0,
    SHARED_RESOURCE_COMPATIBILITY_TIER_1	= ( SHARED_RESOURCE_COMPATIBILITY_TIER_0 + 1 )
};

struct FEATURE_DATA_D3D12_OPTIONS4 {
    Bool mMSAA64KBAlignedTextureSupported;
    SHARED_RESOURCE_COMPATIBILITY_TIER mSharedResourceCompatibilityTier;
    Bool mNative16BitShaderOpsSupported;
};

enum HEAP_SERIALIZATION_TIER : uint32_t {
    HEAP_SERIALIZATION_TIER_0	= 0,
    HEAP_SERIALIZATION_TIER_10	= 10
};

struct FEATURE_DATA_SERIALIZATION {
    uint32_t mNodeIndex;
    HEAP_SERIALIZATION_TIER mHeapSerializationTier;
};

struct FEATURE_DATA_CROSS_NODE {
    CROSS_NODE_SHARING_TIER mSharingTier;
    Bool mAtomicShaderInstructions;
};

enum RENDER_PASS_TIER : uint32_t {
    RENDER_PASS_TIER_0	= 0,
    RENDER_PASS_TIER_1	= 1,
    RENDER_PASS_TIER_2	= 2
};

enum RAYTRACING_TIER : uint32_t {
    RAYTRACING_TIER_NOT_SUPPORTED	= 0,
    RAYTRACING_TIER_1_0	= 10
};

struct FEATURE_DATA_D3D12_OPTIONS5 {
    Bool mSRVOnlyTiledResourceTier3;
    RENDER_PASS_TIER mRenderPassesTier;
    RAYTRACING_TIER mRaytracingTier;
};

enum VARIABLE_SHADING_RATE_TIER : uint32_t {
    VARIABLE_SHADING_RATE_TIER_NOT_SUPPORTED	= 0,
    VARIABLE_SHADING_RATE_TIER_1	= 1,
    VARIABLE_SHADING_RATE_TIER_2	= 2
};

struct FEATURE_DATA_D3D12_OPTIONS6 {
    Bool mAdditionalShadingRatesSupported;
    Bool mPerPrimitiveShadingRateSupportedWithViewportIndexing;
    VARIABLE_SHADING_RATE_TIER mVariableShadingRateTier;
    uint32_t mShadingRateImageTileSize;
    Bool mBackgroundProcessingSupported;
};

struct FEATURE_DATA_QUERY_META_COMMAND {
    boost::uuids::uuid mCommandId;
    uint32_t mNodeMask;
    const void *mQueryInputData;
    size_t mQueryInputDataSizeInBytes;
    void *mQueryOutputData;
    size_t mQueryOutputDataSizeInBytes;
};

struct RESOURCE_ALLOCATION_INFO {
    uint64_t mSizeInBytes;
    uint64_t mAlignment;
};

struct RESOURCE_ALLOCATION_INFO1 {
    uint64_t mOffset;
    uint64_t mAlignment;
    uint64_t mSizeInBytes;
};

enum HEAP_TYPE : uint32_t {
    HEAP_TYPE_DEFAULT	= 1,
    HEAP_TYPE_UPLOAD	= 2,
    HEAP_TYPE_READBACK	= 3,
    HEAP_TYPE_CUSTOM	= 4
};

enum CPU_PAGE_PROPERTY : uint32_t {
    CPU_PAGE_PROPERTY_UNKNOWN	= 0,
    CPU_PAGE_PROPERTY_NOT_AVAILABLE	= 1,
    CPU_PAGE_PROPERTY_WRITE_COMBINE	= 2,
    CPU_PAGE_PROPERTY_WRITE_BACK	= 3
};

enum MEMORY_POOL : uint32_t {
    MEMORY_POOL_UNKNOWN	= 0,
    MEMORY_POOL_L0	= 1,
    MEMORY_POOL_L1	= 2
};

struct HEAP_PROPERTIES {
    HEAP_TYPE mType;
    CPU_PAGE_PROPERTY mCPUPageProperty;
    MEMORY_POOL mMemoryPoolPreference;
    uint32_t mCreationNodeMask;
    uint32_t mVisibleNodeMask;
};

enum HEAP_FLAGS : uint32_t {
    HEAP_FLAG_NONE	= 0,
    HEAP_FLAG_SHARED	= 0x1,
    HEAP_FLAG_DENY_BUFFERS	= 0x4,
    HEAP_FLAG_ALLOW_DISPLAY	= 0x8,
    HEAP_FLAG_SHARED_CROSS_ADAPTER	= 0x20,
    HEAP_FLAG_DENY_RT_DS_TEXTURES	= 0x40,
    HEAP_FLAG_DENY_NON_RT_DS_TEXTURES	= 0x80,
    HEAP_FLAG_HARDWARE_PROTECTED	= 0x100,
    HEAP_FLAG_ALLOW_WRITE_WATCH	= 0x200,
    HEAP_FLAG_ALLOW_SHADER_ATOMICS	= 0x400,
    HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES	= 0,
    HEAP_FLAG_ALLOW_ONLY_BUFFERS	= 0xc0,
    HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES	= 0x44,
    HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES	= 0x84
};

struct HEAP_DESC {
    uint64_t mSizeInBytes;
    HEAP_PROPERTIES mProperties;
    uint64_t mAlignment;
    HEAP_FLAGS mFlags;
};

enum RESOURCE_DIMENSION : uint32_t {
    RESOURCE_DIMENSION_UNKNOWN	= 0,
    RESOURCE_DIMENSION_BUFFER	= 1,
    RESOURCE_DIMENSION_TEXTURE1D	= 2,
    RESOURCE_DIMENSION_TEXTURE2D	= 3,
    RESOURCE_DIMENSION_TEXTURE3D	= 4
};

enum TEXTURE_LAYOUT : uint32_t {
    TEXTURE_LAYOUT_UNKNOWN	= 0,
    TEXTURE_LAYOUT_ROW_MAJOR	= 1,
    TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE	= 2,
    TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE	= 3
};

enum RESOURCE_FLAGS : uint32_t {
    RESOURCE_FLAG_NONE	= 0,
    RESOURCE_FLAG_ALLOW_RENDER_TARGET	= 0x1,
    RESOURCE_FLAG_ALLOW_DEPTH_STENCIL	= 0x2,
    RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS	= 0x4,
    RESOURCE_FLAG_DENY_SHADER_RESOURCE	= 0x8,
    RESOURCE_FLAG_ALLOW_CROSS_ADAPTER	= 0x10,
    RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS	= 0x20,
    RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY	= 0x40
};

struct RESOURCE_DESC {
    RESOURCE_DIMENSION mDimension;
    uint64_t mAlignment;
    uint64_t mWidth;
    uint32_t mHeight;
    uint16_t mDepthOrArraySize;
    uint16_t mMipLevels;
    Format mFormat;
    DISP_SAMPLE_DESC mSampleDesc;
    TEXTURE_LAYOUT mLayout;
    RESOURCE_FLAGS mFlags;
};

struct DEPTH_STENCIL_VALUE {
    float mDepth;
    uint8_t mStencil;
};

struct CLEAR_VALUE {
    Format mFormat;
    union {
        float mColor[ 4 ];
        DEPTH_STENCIL_VALUE mDepthStencil;
    };
};

struct RANGE {
    size_t mBegin;
    size_t mEnd;
};

struct RANGE_UINT64 {
    uint64_t mBegin;
    uint64_t mEnd;
};

struct SUBRESOURCE_RANGE_UINT64 {
    uint32_t mSubresource;
    RANGE_UINT64 mRange;
};

struct SUBRESOURCE_INFO {
    uint64_t mOffset;
    uint32_t mRowPitch;
    uint32_t mDepthPitch;
};

struct TILED_RESOURCE_COORDINATE {
    uint32_t mX;
    uint32_t mY;
    uint32_t mZ;
    uint32_t mSubresource;
};

struct TILE_REGION_SIZE {
    uint32_t mNumTiles;
    Bool mUseBox;
    uint32_t mWidth;
    uint16_t mHeight;
    uint16_t mDepth;
};

enum TILE_RANGE_FLAGS : uint32_t {
    TILE_RANGE_FLAG_NONE	= 0,
    TILE_RANGE_FLAG_NULL	= 1,
    TILE_RANGE_FLAG_SKIP	= 2,
    TILE_RANGE_FLAG_REUSE_SINGLE_TILE	= 4
};

struct SUBRESOURCE_TILING {
    uint32_t mWidthInTiles;
    uint16_t mHeightInTiles;
    uint16_t mDepthInTiles;
    uint32_t mStartTileIndexInOverallResource;
};

struct TILE_SHAPE {
    uint32_t mWidthInTexels;
    uint32_t mHeightInTexels;
    uint32_t mDepthInTexels;
};

struct PACKED_MIP_INFO {
    uint8_t mNumStandardMips;
    uint8_t mNumPackedMips;
    uint32_t mNumTilesForPackedMips;
    uint32_t mStartTileIndexInOverallResource;
};

enum TILE_MAPPING_FLAGS : uint32_t {
    TILE_MAPPING_FLAG_NONE	= 0,
    TILE_MAPPING_FLAG_NO_HAZARD	= 0x1
};

enum TILE_COPY_FLAGS : uint32_t {
    TILE_COPY_FLAG_NONE	= 0,
    TILE_COPY_FLAG_NO_HAZARD	= 0x1,
    TILE_COPY_FLAG_LINEAR_BUFFER_TO_SWIZZLED_TILED_RESOURCE	= 0x2,
    TILE_COPY_FLAG_SWIZZLED_TILED_RESOURCE_TO_LINEAR_BUFFER	= 0x4
};

enum RESOURCE_STATES : uint32_t {
    RESOURCE_STATE_COMMON	= 0,
    RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER	= 0x1,
    RESOURCE_STATE_INDEX_BUFFER	= 0x2,
    RESOURCE_STATE_RENDER_TARGET	= 0x4,
    RESOURCE_STATE_UNORDERED_ACCESS	= 0x8,
    RESOURCE_STATE_DEPTH_WRITE	= 0x10,
    RESOURCE_STATE_DEPTH_READ	= 0x20,
    RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE	= 0x40,
    RESOURCE_STATE_PIXEL_SHADER_RESOURCE	= 0x80,
    RESOURCE_STATE_STREAM_OUT	= 0x100,
    RESOURCE_STATE_INDIRECT_ARGUMENT	= 0x200,
    RESOURCE_STATE_COPY_DEST	= 0x400,
    RESOURCE_STATE_COPY_SOURCE	= 0x800,
    RESOURCE_STATE_RESOLVE_DEST	= 0x1000,
    RESOURCE_STATE_RESOLVE_SOURCE	= 0x2000,
    RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE	= 0x400000,
    RESOURCE_STATE_SHADING_RATE_SOURCE	= 0x1000000,
    RESOURCE_STATE_GENERIC_READ	= ( ( ( ( ( 0x1 | 0x2 )  | 0x40 )  | 0x80 )  | 0x200 )  | 0x800 ) ,
    RESOURCE_STATE_PRESENT	= 0,
    RESOURCE_STATE_PREDICATION	= 0x200,
    RESOURCE_STATE_VIDEO_DECODE_READ	= 0x10000,
    RESOURCE_STATE_VIDEO_DECODE_WRITE	= 0x20000,
    RESOURCE_STATE_VIDEO_PROCESS_READ	= 0x40000,
    RESOURCE_STATE_VIDEO_PROCESS_WRITE	= 0x80000,
    RESOURCE_STATE_VIDEO_ENCODE_READ	= 0x200000,
    RESOURCE_STATE_VIDEO_ENCODE_WRITE	= 0x800000
};

enum RESOURCE_BARRIER_TYPE : uint32_t {
    RESOURCE_BARRIER_TYPE_TRANSITION	= 0,
    RESOURCE_BARRIER_TYPE_ALIASING	= ( RESOURCE_BARRIER_TYPE_TRANSITION + 1 ) ,
    RESOURCE_BARRIER_TYPE_UAV	= ( RESOURCE_BARRIER_TYPE_ALIASING + 1 )
};

struct RESOURCE_TRANSITION_BARRIER {
    void *mResource;
    uint32_t mSubresource;
    RESOURCE_STATES mStateBefore;
    RESOURCE_STATES mStateAfter;
};

struct RESOURCE_ALIASING_BARRIER {
    void *mResourceBefore;
    void *mResourceAfter;
};

struct RESOURCE_UAV_BARRIER {
    void *mResource;
};

enum RESOURCE_BARRIER_FLAGS : uint32_t {
    RESOURCE_BARRIER_FLAG_NONE	= 0,
    RESOURCE_BARRIER_FLAG_BEGIN_ONLY	= 0x1,
    RESOURCE_BARRIER_FLAG_END_ONLY	= 0x2
};

struct RESOURCE_BARRIER {
    RESOURCE_BARRIER_TYPE mType;
    RESOURCE_BARRIER_FLAGS mFlags;
    union {
        RESOURCE_TRANSITION_BARRIER mTransition;
        RESOURCE_ALIASING_BARRIER mAliasing;
        RESOURCE_UAV_BARRIER mUAV;
    };
};

struct SUBRESOURCE_FOOTPRINT {
    Format mFormat;
    uint32_t mWidth;
    uint32_t mHeight;
    uint32_t mDepth;
    uint32_t mRowPitch;
};

struct PLACED_SUBRESOURCE_FOOTPRINT {
    uint64_t mOffset;
    SUBRESOURCE_FOOTPRINT mFootprint;
};

enum TEXTURE_COPY_TYPE : uint32_t {
    TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX	= 0,
    TEXTURE_COPY_TYPE_PLACED_FOOTPRINT	= 1
};

struct TEXTURE_COPY_LOCATION {
    void *mResource;
    TEXTURE_COPY_TYPE mType;
    union {
        PLACED_SUBRESOURCE_FOOTPRINT mPlacedFootprint;
        uint32_t mSubresourceIndex;
    };
};

enum RESOLVE_MODE : uint32_t {
    RESOLVE_MODE_DECOMPRESS	= 0,
    RESOLVE_MODE_MIN	= 1,
    RESOLVE_MODE_MAX	= 2,
    RESOLVE_MODE_AVERAGE	= 3
};

struct SAMPLE_POSITION {
    int8_t mX;
    int8_t mY;
};

struct VIEW_INSTANCE_LOCATION {
    uint32_t mViewportArrayIndex;
    uint32_t mRenderTargetArrayIndex;
};

enum VIEW_INSTANCING_FLAGS : uint32_t {
    VIEW_INSTANCING_FLAG_NONE	= 0,
    VIEW_INSTANCING_FLAG_ENABLE_VIEW_INSTANCE_MASKING	= 0x1
};

struct VIEW_INSTANCING_DESC {
    uint32_t mViewInstanceCount;
    const VIEW_INSTANCE_LOCATION *mViewInstanceLocations;
    VIEW_INSTANCING_FLAGS mFlags;
};

enum SHADER_COMPONENT_MAPPING : uint32_t {
    SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0	= 0,
    SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_1	= 1,
    SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_2	= 2,
    SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3	= 3,
    SHADER_COMPONENT_MAPPING_FORCE_VALUE_0	= 4,
    SHADER_COMPONENT_MAPPING_FORCE_VALUE_1	= 5
};

enum BUFFER_SRV_FLAGS : uint32_t {
    BUFFER_SRV_FLAG_NONE	= 0,
    BUFFER_SRV_FLAG_RAW	= 0x1
};

struct BUFFER_SRV {
    uint64_t mFirstElement;
    uint32_t mNumElements;
    uint32_t mStructureByteStride;
    BUFFER_SRV_FLAGS mFlags;
};

struct TEX1D_SRV {
    uint32_t mMostDetailedMip;
    uint32_t mMipLevels;
    float mResourceMinLODClamp;
};

struct TEX1D_ARRAY_SRV {
    uint32_t mMostDetailedMip;
    uint32_t mMipLevels;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
    float mResourceMinLODClamp;
};

struct TEX2D_SRV {
    uint32_t mMostDetailedMip;
    uint32_t mMipLevels;
    uint32_t mPlaneSlice;
    float mResourceMinLODClamp;
};

struct TEX2D_ARRAY_SRV {
    uint32_t mMostDetailedMip;
    uint32_t mMipLevels;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
    uint32_t mPlaneSlice;
    float mResourceMinLODClamp;
};

struct TEX3D_SRV {
    uint32_t mMostDetailedMip;
    uint32_t mMipLevels;
    float mResourceMinLODClamp;
};

struct TEXCUBE_SRV {
    uint32_t mMostDetailedMip;
    uint32_t mMipLevels;
    float mResourceMinLODClamp;
};

struct TEXCUBE_ARRAY_SRV {
    uint32_t mMostDetailedMip;
    uint32_t mMipLevels;
    uint32_t mFirst2DArrayFace;
    uint32_t mNumCubes;
    float mResourceMinLODClamp;
};

struct TEX2DMS_SRV {
    uint32_t mUnusedField_NothingToDefine;
};

struct TEX2DMS_ARRAY_SRV {
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
};

struct RAYTRACING_ACCELERATION_STRUCTURE_SRV {
    GPU_VIRTUAL_ADDRESS mLocation;
};

enum SRV_DIMENSION : uint32_t {
    SRV_DIMENSION_UNKNOWN	= 0,
    SRV_DIMENSION_BUFFER	= 1,
    SRV_DIMENSION_TEXTURE1D	= 2,
    SRV_DIMENSION_TEXTURE1DARRAY	= 3,
    SRV_DIMENSION_TEXTURE2D	= 4,
    SRV_DIMENSION_TEXTURE2DARRAY	= 5,
    SRV_DIMENSION_TEXTURE2DMS	= 6,
    SRV_DIMENSION_TEXTURE2DMSARRAY	= 7,
    SRV_DIMENSION_TEXTURE3D	= 8,
    SRV_DIMENSION_TEXTURECUBE	= 9,
    SRV_DIMENSION_TEXTURECUBEARRAY	= 10,
    SRV_DIMENSION_RAYTRACING_ACCELERATION_STRUCTURE	= 11
};

struct SHADER_RESOURCE_VIEW_DESC {
    Format mFormat;
    SRV_DIMENSION mViewDimension;
    uint32_t mShader4ComponentMapping;
    union {
        BUFFER_SRV mBuffer;
        TEX1D_SRV mTexture1D;
        TEX1D_ARRAY_SRV mTexture1DArray;
        TEX2D_SRV mTexture2D;
        TEX2D_ARRAY_SRV mTexture2DArray;
        TEX2DMS_SRV mTexture2DMS;
        TEX2DMS_ARRAY_SRV mTexture2DMSArray;
        TEX3D_SRV mTexture3D;
        TEXCUBE_SRV mTextureCube;
        TEXCUBE_ARRAY_SRV mTextureCubeArray;
        RAYTRACING_ACCELERATION_STRUCTURE_SRV mRaytracingAccelerationStructure;
    };
};

struct CONSTANT_BUFFER_VIEW_DESC {
    GPU_VIRTUAL_ADDRESS mBufferLocation;
    uint32_t mSizeInBytes;
};

enum FILTER : uint32_t {
    FILTER_MIN_MAG_MIP_POINT	= 0,
    FILTER_MIN_MAG_POINT_MIP_LINEAR	= 0x1,
    FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT	= 0x4,
    FILTER_MIN_POINT_MAG_MIP_LINEAR	= 0x5,
    FILTER_MIN_LINEAR_MAG_MIP_POINT	= 0x10,
    FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR	= 0x11,
    FILTER_MIN_MAG_LINEAR_MIP_POINT	= 0x14,
    FILTER_MIN_MAG_MIP_LINEAR	= 0x15,
    FILTER_ANISOTROPIC	= 0x55,
    FILTER_COMPARISON_MIN_MAG_MIP_POINT	= 0x80,
    FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR	= 0x81,
    FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT	= 0x84,
    FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR	= 0x85,
    FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT	= 0x90,
    FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR	= 0x91,
    FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT	= 0x94,
    FILTER_COMPARISON_MIN_MAG_MIP_LINEAR	= 0x95,
    FILTER_COMPARISON_ANISOTROPIC	= 0xd5,
    FILTER_MINIMUM_MIN_MAG_MIP_POINT	= 0x100,
    FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR	= 0x101,
    FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT	= 0x104,
    FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR	= 0x105,
    FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT	= 0x110,
    FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR	= 0x111,
    FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT	= 0x114,
    FILTER_MINIMUM_MIN_MAG_MIP_LINEAR	= 0x115,
    FILTER_MINIMUM_ANISOTROPIC	= 0x155,
    FILTER_MAXIMUM_MIN_MAG_MIP_POINT	= 0x180,
    FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR	= 0x181,
    FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT	= 0x184,
    FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR	= 0x185,
    FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT	= 0x190,
    FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR	= 0x191,
    FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT	= 0x194,
    FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR	= 0x195,
    FILTER_MAXIMUM_ANISOTROPIC	= 0x1d5
};

enum FILTER_TYPE : uint32_t {
    FILTER_TYPE_POINT	= 0,
    FILTER_TYPE_LINEAR	= 1
};

enum FILTER_REDUCTION_TYPE : uint32_t {
    FILTER_REDUCTION_TYPE_STANDARD	= 0,
    FILTER_REDUCTION_TYPE_COMPARISON	= 1,
    FILTER_REDUCTION_TYPE_MINIMUM	= 2,
    FILTER_REDUCTION_TYPE_MAXIMUM	= 3
};

enum TEXTURE_ADDRESS_MODE : uint32_t {
    TEXTURE_ADDRESS_MODE_WRAP	= 1,
    TEXTURE_ADDRESS_MODE_MIRROR	= 2,
    TEXTURE_ADDRESS_MODE_CLAMP	= 3,
    TEXTURE_ADDRESS_MODE_BORDER	= 4,
    TEXTURE_ADDRESS_MODE_MIRROR_ONCE	= 5
};

struct SAMPLER_DESC {
    FILTER mFilter;
    TEXTURE_ADDRESS_MODE mAddressU;
    TEXTURE_ADDRESS_MODE mAddressV;
    TEXTURE_ADDRESS_MODE mAddressW;
    float mMipLODBias;
    uint32_t mMaxAnisotropy;
    COMPARISON_FUNC mComparisonFunc;
    float mBorderColor[ 4 ];
    float mMinLOD;
    float mMaxLOD;
};

enum BUFFER_UAV_FLAGS : uint32_t {
    BUFFER_UAV_FLAG_NONE	= 0,
    BUFFER_UAV_FLAG_RAW	= 0x1
};

struct BUFFER_UAV {
    uint64_t mFirstElement;
    uint32_t mNumElements;
    uint32_t mStructureByteStride;
    uint64_t mCounterOffsetInBytes;
    BUFFER_UAV_FLAGS mFlags;
};

struct TEX1D_UAV {
    uint32_t mMipSlice;
};

struct TEX1D_ARRAY_UAV {
    uint32_t mMipSlice;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
};

struct TEX2D_UAV {
    uint32_t mMipSlice;
    uint32_t mPlaneSlice;
};

struct TEX2D_ARRAY_UAV {
    uint32_t mMipSlice;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
    uint32_t mPlaneSlice;
};

struct TEX3D_UAV {
    uint32_t mMipSlice;
    uint32_t mFirstWSlice;
    uint32_t mWSize;
};

enum UAV_DIMENSION : uint32_t {
    UAV_DIMENSION_UNKNOWN	= 0,
    UAV_DIMENSION_BUFFER	= 1,
    UAV_DIMENSION_TEXTURE1D	= 2,
    UAV_DIMENSION_TEXTURE1DARRAY	= 3,
    UAV_DIMENSION_TEXTURE2D	= 4,
    UAV_DIMENSION_TEXTURE2DARRAY	= 5,
    UAV_DIMENSION_TEXTURE3D	= 8
};

struct UNORDERED_ACCESS_VIEW_DESC {
    Format mFormat;
    UAV_DIMENSION mViewDimension;
    union {
        BUFFER_UAV mBuffer;
        TEX1D_UAV mTexture1D;
        TEX1D_ARRAY_UAV mTexture1DArray;
        TEX2D_UAV mTexture2D;
        TEX2D_ARRAY_UAV mTexture2DArray;
        TEX3D_UAV mTexture3D;
    };
};

struct BUFFER_RTV {
    uint64_t mFirstElement;
    uint32_t mNumElements;
};

struct TEX1D_RTV {
    uint32_t mMipSlice;
};

struct TEX1D_ARRAY_RTV {
    uint32_t mMipSlice;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
};

struct TEX2D_RTV {
    uint32_t mMipSlice;
    uint32_t mPlaneSlice;
};

struct TEX2DMS_RTV {
    uint32_t mUnusedField_NothingToDefine;
};

struct TEX2D_ARRAY_RTV {
    uint32_t mMipSlice;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
    uint32_t mPlaneSlice;
};

struct TEX2DMS_ARRAY_RTV {
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
};

struct TEX3D_RTV {
    uint32_t mMipSlice;
    uint32_t mFirstWSlice;
    uint32_t mWSize;
};

enum RTV_DIMENSION : uint32_t {
    RTV_DIMENSION_UNKNOWN	= 0,
    RTV_DIMENSION_BUFFER	= 1,
    RTV_DIMENSION_TEXTURE1D	= 2,
    RTV_DIMENSION_TEXTURE1DARRAY	= 3,
    RTV_DIMENSION_TEXTURE2D	= 4,
    RTV_DIMENSION_TEXTURE2DARRAY	= 5,
    RTV_DIMENSION_TEXTURE2DMS	= 6,
    RTV_DIMENSION_TEXTURE2DMSARRAY	= 7,
    RTV_DIMENSION_TEXTURE3D	= 8
};

struct RENDER_TARGET_VIEW_DESC {
    Format mFormat;
    RTV_DIMENSION mViewDimension;
    union {
        BUFFER_RTV mBuffer;
        TEX1D_RTV mTexture1D;
        TEX1D_ARRAY_RTV mTexture1DArray;
        TEX2D_RTV mTexture2D;
        TEX2D_ARRAY_RTV mTexture2DArray;
        TEX2DMS_RTV mTexture2DMS;
        TEX2DMS_ARRAY_RTV mTexture2DMSArray;
        TEX3D_RTV mTexture3D;
    };
};

struct TEX1D_DSV {
    uint32_t mMipSlice;
};

struct TEX1D_ARRAY_DSV {
    uint32_t mMipSlice;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
};

struct TEX2D_DSV {
    uint32_t mMipSlice;
};

struct TEX2D_ARRAY_DSV {
    uint32_t mMipSlice;
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
};

struct TEX2DMS_DSV {
    uint32_t mUnusedField_NothingToDefine;
};

struct TEX2DMS_ARRAY_DSV {
    uint32_t mFirstArraySlice;
    uint32_t mArraySize;
};

enum DSV_FLAGS : uint32_t {
    DSV_FLAG_NONE	= 0,
    DSV_FLAG_READ_ONLY_DEPTH	= 0x1,
    DSV_FLAG_READ_ONLY_STENCIL	= 0x2
};

enum DSV_DIMENSION : uint32_t {
    DSV_DIMENSION_UNKNOWN	= 0,
    DSV_DIMENSION_TEXTURE1D	= 1,
    DSV_DIMENSION_TEXTURE1DARRAY	= 2,
    DSV_DIMENSION_TEXTURE2D	= 3,
    DSV_DIMENSION_TEXTURE2DARRAY	= 4,
    DSV_DIMENSION_TEXTURE2DMS	= 5,
    DSV_DIMENSION_TEXTURE2DMSARRAY	= 6
};

struct DEPTH_STENCIL_VIEW_DESC {
    Format mFormat;
    DSV_DIMENSION mViewDimension;
    DSV_FLAGS mFlags;
    union {
        TEX1D_DSV mTexture1D;
        TEX1D_ARRAY_DSV mTexture1DArray;
        TEX2D_DSV mTexture2D;
        TEX2D_ARRAY_DSV mTexture2DArray;
        TEX2DMS_DSV mTexture2DMS;
        TEX2DMS_ARRAY_DSV mTexture2DMSArray;
    };
};

enum CLEAR_FLAGS : uint32_t {
    CLEAR_FLAG_DEPTH	= 0x1,
    CLEAR_FLAG_STENCIL	= 0x2
};

enum FENCE_FLAGS : uint32_t {
    FENCE_FLAG_NONE	= 0,
    FENCE_FLAG_SHARED	= 0x1,
    FENCE_FLAG_SHARED_CROSS_ADAPTER	= 0x2,
    FENCE_FLAG_NON_MONITORED	= 0x4
};

enum DESCRIPTOR_HEAP_TYPE : uint32_t {
    DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV	= 0,
    DESCRIPTOR_HEAP_TYPE_SAMPLER	= ( DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV + 1 ) ,
    DESCRIPTOR_HEAP_TYPE_RTV	= ( DESCRIPTOR_HEAP_TYPE_SAMPLER + 1 ) ,
    DESCRIPTOR_HEAP_TYPE_DSV	= ( DESCRIPTOR_HEAP_TYPE_RTV + 1 ) ,
    DESCRIPTOR_HEAP_TYPE_NUM_TYPES	= ( DESCRIPTOR_HEAP_TYPE_DSV + 1 )
};

enum DESCRIPTOR_HEAP_FLAGS : uint32_t {
    DESCRIPTOR_HEAP_FLAG_NONE	= 0,
    DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE	= 0x1
};

struct DESCRIPTOR_HEAP_DESC {
    DESCRIPTOR_HEAP_TYPE mType;
    uint32_t mNumDescriptors;
    DESCRIPTOR_HEAP_FLAGS mFlags;
    uint32_t mNodeMask;
};

enum DESCRIPTOR_RANGE_TYPE : uint32_t {
    DESCRIPTOR_RANGE_TYPE_SRV	= 0,
    DESCRIPTOR_RANGE_TYPE_UAV	= ( DESCRIPTOR_RANGE_TYPE_SRV + 1 ) ,
    DESCRIPTOR_RANGE_TYPE_CBV	= ( DESCRIPTOR_RANGE_TYPE_UAV + 1 ) ,
    DESCRIPTOR_RANGE_TYPE_SAMPLER	= ( DESCRIPTOR_RANGE_TYPE_CBV + 1 )
};

struct DESCRIPTOR_RANGE {
    DESCRIPTOR_RANGE_TYPE mRangeType;
    uint32_t mNumDescriptors;
    uint32_t mBaseShaderRegister;
    uint32_t mRegisterSpace;
    uint32_t mOffsetInDescriptorsFromTableStart;
};

struct ROOT_DESCRIPTOR_TABLE {
    uint32_t mNumDescriptorRanges;
    const DESCRIPTOR_RANGE *mDescriptorRanges;
};

struct ROOT_CONSTANTS {
    uint32_t mShaderRegister;
    uint32_t mRegisterSpace;
    uint32_t mNum32BitValues;
};

struct ROOT_DESCRIPTOR {
    uint32_t mShaderRegister;
    uint32_t mRegisterSpace;
};

enum SHADER_VISIBILITY : uint32_t {
    SHADER_VISIBILITY_ALL	= 0,
    SHADER_VISIBILITY_VERTEX	= 1,
    SHADER_VISIBILITY_HULL	= 2,
    SHADER_VISIBILITY_DOMAIN	= 3,
    SHADER_VISIBILITY_GEOMETRY	= 4,
    SHADER_VISIBILITY_PIXEL	= 5
};

enum ROOT_PARAMETER_TYPE : uint32_t {
    ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE	= 0,
    ROOT_PARAMETER_TYPE_32BIT_CONSTANTS	= ( ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE + 1 ) ,
    ROOT_PARAMETER_TYPE_CBV	= ( ROOT_PARAMETER_TYPE_32BIT_CONSTANTS + 1 ) ,
    ROOT_PARAMETER_TYPE_SRV	= ( ROOT_PARAMETER_TYPE_CBV + 1 ) ,
    ROOT_PARAMETER_TYPE_UAV	= ( ROOT_PARAMETER_TYPE_SRV + 1 )
};

struct ROOT_PARAMETER {
    ROOT_PARAMETER_TYPE mParameterType;
    union {
        ROOT_DESCRIPTOR_TABLE mDescriptorTable;
        ROOT_CONSTANTS mConstants;
        ROOT_DESCRIPTOR mDescriptor;
    };
    SHADER_VISIBILITY mShaderVisibility;
};

enum ROOT_SIGNATURE_FLAGS : uint32_t {
    ROOT_SIGNATURE_FLAG_NONE	= 0,
    ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT	= 0x1,
    ROOT_SIGNATURE_FLAG_DENY_VERTEX_SHADER_ROOT_ACCESS	= 0x2,
    ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS	= 0x4,
    ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS	= 0x8,
    ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS	= 0x10,
    ROOT_SIGNATURE_FLAG_DENY_PIXEL_SHADER_ROOT_ACCESS	= 0x20,
    ROOT_SIGNATURE_FLAG_ALLOW_STREAM_OUTPUT	= 0x40,
    ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE	= 0x80
};

enum STATIC_BORDER_COLOR : uint32_t {
    STATIC_BORDER_COLOR_TRANSPARENT_BLACK	= 0,
    STATIC_BORDER_COLOR_OPAQUE_BLACK	= ( STATIC_BORDER_COLOR_TRANSPARENT_BLACK + 1 ) ,
    STATIC_BORDER_COLOR_OPAQUE_WHITE	= ( STATIC_BORDER_COLOR_OPAQUE_BLACK + 1 )
};

struct STATIC_SAMPLER_DESC {
    FILTER mFilter;
    TEXTURE_ADDRESS_MODE mAddressU;
    TEXTURE_ADDRESS_MODE mAddressV;
    TEXTURE_ADDRESS_MODE mAddressW;
    float mMipLODBias;
    uint32_t mMaxAnisotropy;
    COMPARISON_FUNC mComparisonFunc;
    STATIC_BORDER_COLOR mBorderColor;
    float mMinLOD;
    float mMaxLOD;
    uint32_t mShaderRegister;
    uint32_t mRegisterSpace;
    SHADER_VISIBILITY mShaderVisibility;
};

struct ROOT_SIGNATURE_DESC {
    uint32_t mNumParameters;
    const ROOT_PARAMETER *mParameters;
    uint32_t mNumStaticSamplers;
    const STATIC_SAMPLER_DESC *mStaticSamplers;
    ROOT_SIGNATURE_FLAGS mFlags;
};

enum DESCRIPTOR_RANGE_FLAGS : uint32_t {
    DESCRIPTOR_RANGE_FLAG_NONE	= 0,
    DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE	= 0x1,
    DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE	= 0x2,
    DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE	= 0x4,
    DESCRIPTOR_RANGE_FLAG_DATA_STATIC	= 0x8,
    DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS	= 0x10000
};

struct DESCRIPTOR_RANGE1 {
    DESCRIPTOR_RANGE_TYPE mRangeType;
    uint32_t mNumDescriptors;
    uint32_t mBaseShaderRegister;
    uint32_t mRegisterSpace;
    DESCRIPTOR_RANGE_FLAGS mFlags;
    uint32_t mOffsetInDescriptorsFromTableStart;
};

struct ROOT_DESCRIPTOR_TABLE1 {
    uint32_t mNumDescriptorRanges;
    const DESCRIPTOR_RANGE1 *mDescriptorRanges;
};

enum ROOT_DESCRIPTOR_FLAGS : uint32_t {
    ROOT_DESCRIPTOR_FLAG_NONE	= 0,
    ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE	= 0x2,
    ROOT_DESCRIPTOR_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE	= 0x4,
    ROOT_DESCRIPTOR_FLAG_DATA_STATIC	= 0x8
};

struct ROOT_DESCRIPTOR1 {
    uint32_t mShaderRegister;
    uint32_t mRegisterSpace;
    ROOT_DESCRIPTOR_FLAGS mFlags;
};

struct ROOT_PARAMETER1 {
    ROOT_PARAMETER_TYPE mParameterType;
    union {
        ROOT_DESCRIPTOR_TABLE1 mDescriptorTable;
        ROOT_CONSTANTS mConstants;
        ROOT_DESCRIPTOR1 mDescriptor;
    };
    SHADER_VISIBILITY mShaderVisibility;
};

struct ROOT_SIGNATURE_DESC1 {
    uint32_t mNumParameters;
    const ROOT_PARAMETER1 *mParameters;
    uint32_t mNumStaticSamplers;
    const STATIC_SAMPLER_DESC *mStaticSamplers;
    ROOT_SIGNATURE_FLAGS mFlags;
};

struct VERSIONED_ROOT_SIGNATURE_DESC {
    GFX_ROOT_SIGNATURE_VERSION mVersion;
    union {
        ROOT_SIGNATURE_DESC mDesc_1_0;
        ROOT_SIGNATURE_DESC1 mDesc_1_1;
    };
};

struct CPU_DESCRIPTOR_HANDLE {
    size_t mptr;
};

struct GPU_DESCRIPTOR_HANDLE {
    uint64_t mptr;
};

struct DISCARD_REGION {
    uint32_t mNumRects;
    const RECT *mRects;
    uint32_t mFirstSubresource;
    uint32_t mNumSubresources;
};

enum QUERY_HEAP_TYPE : uint32_t {
    QUERY_HEAP_TYPE_OCCLUSION	= 0,
    QUERY_HEAP_TYPE_TIMESTAMP	= 1,
    QUERY_HEAP_TYPE_PIPELINE_STATISTICS	= 2,
    QUERY_HEAP_TYPE_SO_STATISTICS	= 3,
    QUERY_HEAP_TYPE_VIDEO_DECODE_STATISTICS	= 4,
    QUERY_HEAP_TYPE_COPY_QUEUE_TIMESTAMP	= 5
};

struct QUERY_HEAP_DESC {
    QUERY_HEAP_TYPE mType;
    uint32_t mCount;
    uint32_t mNodeMask;
};

enum QUERY_TYPE : uint32_t {
    QUERY_TYPE_OCCLUSION	= 0,
    QUERY_TYPE_BINARY_OCCLUSION	= 1,
    QUERY_TYPE_TIMESTAMP	= 2,
    QUERY_TYPE_PIPELINE_STATISTICS	= 3,
    QUERY_TYPE_SO_STATISTICS_STREAM0	= 4,
    QUERY_TYPE_SO_STATISTICS_STREAM1	= 5,
    QUERY_TYPE_SO_STATISTICS_STREAM2	= 6,
    QUERY_TYPE_SO_STATISTICS_STREAM3	= 7,
    QUERY_TYPE_VIDEO_DECODE_STATISTICS	= 8
};

enum PREDICATION_OP : uint32_t {
    PREDICATION_OP_EQUAL_ZERO	= 0,
    PREDICATION_OP_NOT_EQUAL_ZERO	= 1
};

struct QUERY_DATA_PIPELINE_STATISTICS {
    uint64_t mIAVertices;
    uint64_t mIAPrimitives;
    uint64_t mVSInvocations;
    uint64_t mGSInvocations;
    uint64_t mGSPrimitives;
    uint64_t mCInvocations;
    uint64_t mCPrimitives;
    uint64_t mPSInvocations;
    uint64_t mHSInvocations;
    uint64_t mDSInvocations;
    uint64_t mCSInvocations;
};

struct QUERY_DATA_SO_STATISTICS {
    uint64_t mNumPrimitivesWritten;
    uint64_t mPrimitivesStorageNeeded;
};

struct STREAM_OUTPUT_BUFFER_VIEW {
    GPU_VIRTUAL_ADDRESS mBufferLocation;
    uint64_t mSizeInBytes;
    GPU_VIRTUAL_ADDRESS mBufferFilledSizeLocation;
};

struct DRAW_ARGUMENTS {
    uint32_t mVertexCountPerInstance;
    uint32_t mInstanceCount;
    uint32_t mStartVertexLocation;
    uint32_t mStartInstanceLocation;
};

struct DRAW_INDEXED_ARGUMENTS {
    uint32_t mIndexCountPerInstance;
    uint32_t mInstanceCount;
    uint32_t mStartIndexLocation;
    int32_t mBaseVertexLocation;
    uint32_t mStartInstanceLocation;
};

struct DISPATCH_ARGUMENTS {
    uint32_t mThreadGroupCountX;
    uint32_t mThreadGroupCountY;
    uint32_t mThreadGroupCountZ;
};

struct VERTEX_BUFFER_VIEW {
    GPU_VIRTUAL_ADDRESS mBufferLocation;
    uint32_t mSizeInBytes;
    uint32_t mStrideInBytes;
};

struct INDEX_BUFFER_VIEW {
    GPU_VIRTUAL_ADDRESS mBufferLocation;
    uint32_t mSizeInBytes;
    Format mFormat;
};

enum INDIRECT_ARGUMENT_TYPE : uint32_t {
    INDIRECT_ARGUMENT_TYPE_DRAW	= 0,
    INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED	= ( INDIRECT_ARGUMENT_TYPE_DRAW + 1 ) ,
    INDIRECT_ARGUMENT_TYPE_DISPATCH	= ( INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED + 1 ) ,
    INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW	= ( INDIRECT_ARGUMENT_TYPE_DISPATCH + 1 ) ,
    INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW	= ( INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW + 1 ) ,
    INDIRECT_ARGUMENT_TYPE_CONSTANT	= ( INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW + 1 ) ,
    INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW	= ( INDIRECT_ARGUMENT_TYPE_CONSTANT + 1 ) ,
    INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW	= ( INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW + 1 ) ,
    INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW	= ( INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW + 1 )
};

struct INDIRECT_ARGUMENT_DESC {
    INDIRECT_ARGUMENT_TYPE mType;
    union {
        struct {
            uint32_t mSlot;
        } VertexBuffer;
        struct {
            uint32_t mRootParameterIndex;
            uint32_t mDestOffsetIn32BitValues;
            uint32_t mNum32BitValuesToSet;
        } Constant;
        struct {
            uint32_t mRootParameterIndex;
        } ConstantBufferView;
        struct {
            uint32_t mRootParameterIndex;
        } ShaderResourceView;
        struct {
            uint32_t mRootParameterIndex;
        } UnorderedAccessView;
    };
};

struct COMMAND_SIGNATURE_DESC {
    uint32_t mByteStride;
    uint32_t mNumArgumentDescs;
    const INDIRECT_ARGUMENT_DESC *mArgumentDescs;
    uint32_t mNodeMask;
};

struct WRITEBUFFERIMMEDIATE_PARAMETER {
    GPU_VIRTUAL_ADDRESS mDest;
    uint32_t mValue;
};

enum WRITEBUFFERIMMEDIATE_MODE : uint32_t {
    WRITEBUFFERIMMEDIATE_MODE_DEFAULT	= 0,
    WRITEBUFFERIMMEDIATE_MODE_MARKER_IN	= 0x1,
    WRITEBUFFERIMMEDIATE_MODE_MARKER_OUT	= 0x2
};

enum MULTIPLE_FENCE_WAIT_FLAGS : uint32_t {
    MULTIPLE_FENCE_WAIT_FLAG_NONE	= 0,
    MULTIPLE_FENCE_WAIT_FLAG_ANY	= 0x1,
    MULTIPLE_FENCE_WAIT_FLAG_ALL	= 0
};

enum RESIDENCY_PRIORITY : uint32_t {
    RESIDENCY_PRIORITY_MINIMUM	= 0x28000000,
    RESIDENCY_PRIORITY_LOW	= 0x50000000,
    RESIDENCY_PRIORITY_NORMAL	= 0x78000000,
    RESIDENCY_PRIORITY_HIGH	= 0xa0010000,
    RESIDENCY_PRIORITY_MAXIMUM	= 0xc8000000
};

enum RESIDENCY_FLAGS : uint32_t {
    RESIDENCY_FLAG_NONE	= 0,
    RESIDENCY_FLAG_DENY_OVERBUDGET	= 0x1
};

enum COMMAND_LIST_FLAGS : uint32_t {
    COMMAND_LIST_FLAG_NONE	= 0
};

enum COMMAND_POOL_FLAGS : uint32_t {
    COMMAND_POOL_FLAG_NONE	= 0
};

enum COMMAND_RECORDER_FLAGS : uint32_t {
    COMMAND_RECORDER_FLAG_NONE	= 0
};

enum PROTECTED_SESSION_STATUS : uint32_t {
    PROTECTED_SESSION_STATUS_OK	= 0,
    PROTECTED_SESSION_STATUS_INVALID	= 1
};

enum PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS : uint32_t {
    PROTECTED_RESOURCE_SESSION_SUPPORT_FLAG_NONE	= 0,
    PROTECTED_RESOURCE_SESSION_SUPPORT_FLAG_SUPPORTED	= 0x1
};

struct FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {
    uint32_t mNodeIndex;
    PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS mSupport;
};

enum PROTECTED_RESOURCE_SESSION_FLAGS : uint32_t {
    PROTECTED_RESOURCE_SESSION_FLAG_NONE	= 0
};

struct PROTECTED_RESOURCE_SESSION_DESC {
    uint32_t mNodeMask;
    PROTECTED_RESOURCE_SESSION_FLAGS mFlags;
};

enum LIFETIME_STATE : uint32_t {
    LIFETIME_STATE_IN_USE	= 0,
    LIFETIME_STATE_NOT_IN_USE	= ( LIFETIME_STATE_IN_USE + 1 )
};

enum META_COMMAND_PARAMETER_TYPE : uint32_t {
    META_COMMAND_PARAMETER_TYPE_FLOAT	= 0,
    META_COMMAND_PARAMETER_TYPE_UINT64	= 1,
    META_COMMAND_PARAMETER_TYPE_GPU_VIRTUAL_ADDRESS	= 2,
    META_COMMAND_PARAMETER_TYPE_CPU_DESCRIPTOR_HANDLE_HEAP_TYPE_CBV_SRV_UAV	= 3,
    META_COMMAND_PARAMETER_TYPE_GPU_DESCRIPTOR_HANDLE_HEAP_TYPE_CBV_SRV_UAV	= 4
};

enum META_COMMAND_PARAMETER_FLAGS : uint32_t {
    META_COMMAND_PARAMETER_FLAG_INPUT	= 0x1,
    META_COMMAND_PARAMETER_FLAG_OUTPUT	= 0x2
};

enum META_COMMAND_PARAMETER_STAGE : uint32_t {
    META_COMMAND_PARAMETER_STAGE_CREATION	= 0,
    META_COMMAND_PARAMETER_STAGE_INITIALIZATION	= 1,
    META_COMMAND_PARAMETER_STAGE_EXECUTION	= 2
};

struct META_COMMAND_PARAMETER_DESC {
    const wchar_t* mName;
    META_COMMAND_PARAMETER_TYPE mType;
    META_COMMAND_PARAMETER_FLAGS mFlags;
    RESOURCE_STATES mRequiredResourceState;
    uint32_t mStructureOffset;
};

enum GRAPHICS_STATES : uint32_t {
    GRAPHICS_STATE_NONE	= 0,
    GRAPHICS_STATE_IA_VERTEX_BUFFERS	= ( 1 << 0 ) ,
    GRAPHICS_STATE_IA_INDEX_BUFFER	= ( 1 << 1 ) ,
    GRAPHICS_STATE_IA_PRIMITIVE_TOPOLOGY	= ( 1 << 2 ) ,
    GRAPHICS_STATE_DESCRIPTOR_HEAP	= ( 1 << 3 ) ,
    GRAPHICS_STATE_GRAPHICS_ROOT_SIGNATURE	= ( 1 << 4 ) ,
    GRAPHICS_STATE_COMPUTE_ROOT_SIGNATURE	= ( 1 << 5 ) ,
    GRAPHICS_STATE_RS_VIEWPORTS	= ( 1 << 6 ) ,
    GRAPHICS_STATE_RS_SCISSOR_RECTS	= ( 1 << 7 ) ,
    GRAPHICS_STATE_PREDICATION	= ( 1 << 8 ) ,
    GRAPHICS_STATE_OM_RENDER_TARGETS	= ( 1 << 9 ) ,
    GRAPHICS_STATE_OM_STENCIL_REF	= ( 1 << 10 ) ,
    GRAPHICS_STATE_OM_BLEND_FACTOR	= ( 1 << 11 ) ,
    GRAPHICS_STATE_PIPELINE_STATE	= ( 1 << 12 ) ,
    GRAPHICS_STATE_SO_TARGETS	= ( 1 << 13 ) ,
    GRAPHICS_STATE_OM_DEPTH_BOUNDS	= ( 1 << 14 ) ,
    GRAPHICS_STATE_SAMPLE_POSITIONS	= ( 1 << 15 ) ,
    GRAPHICS_STATE_VIEW_INSTANCE_MASK	= ( 1 << 16 )
};

struct META_COMMAND_DESC {
    boost::uuids::uuid mId;
    const wchar_t* mName;
    GRAPHICS_STATES mInitializationDirtyState;
    GRAPHICS_STATES mExecutionDirtyState;
};

enum STATE_SUBOBJECT_TYPE : uint32_t {
    STATE_SUBOBJECT_TYPE_STATE_OBJECT_CONFIG	= 0,
    STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE	= 1,
    STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE	= 2,
    STATE_SUBOBJECT_TYPE_NODE_MASK	= 3,
    STATE_SUBOBJECT_TYPE_DXIL_LIBRARY	= 5,
    STATE_SUBOBJECT_TYPE_EXISTING_COLLECTION	= 6,
    STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION	= 7,
    STATE_SUBOBJECT_TYPE_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION	= 8,
    STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG	= 9,
    STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG	= 10,
    STATE_SUBOBJECT_TYPE_HIT_GROUP	= 11,
    STATE_SUBOBJECT_TYPE_MAX_VALID	= ( STATE_SUBOBJECT_TYPE_HIT_GROUP + 1 )
};

struct STATE_SUBOBJECT {
    STATE_SUBOBJECT_TYPE mType;
    const void *mDesc;
};

enum STATE_OBJECT_FLAGS : uint32_t {
    STATE_OBJECT_FLAG_NONE	= 0,
    STATE_OBJECT_FLAG_ALLOW_LOCAL_DEPENDENCIES_ON_EXTERNAL_DEFINITIONS	= 0x1,
    STATE_OBJECT_FLAG_ALLOW_EXTERNAL_DEPENDENCIES_ON_LOCAL_DEFINITIONS	= 0x2
};

struct STATE_OBJECT_CONFIG {
    STATE_OBJECT_FLAGS mFlags;
};

struct GLOBAL_ROOT_SIGNATURE {
    void *mGlobalRootSignature;
};

struct LOCAL_ROOT_SIGNATURE {
    void *mLocalRootSignature;
};

struct NODE_MASK {
    uint32_t mNodeMask;
};

enum EXPORT_FLAGS : uint32_t {
    EXPORT_FLAG_NONE	= 0
};

struct EXPORT_DESC {
    const wchar_t* mName;
    const wchar_t* mExportToRename;
    EXPORT_FLAGS mFlags;
};

struct DXIL_LIBRARY_DESC {
    SHADER_BYTECODE mDXILLibrary;
    uint32_t mNumExports;
    EXPORT_DESC *mExports;
};

struct EXISTING_COLLECTION_DESC {
    void *mExistingCollection;
    uint32_t mNumExports;
    EXPORT_DESC *mExports;
};

struct SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    const STATE_SUBOBJECT *mSubobjectToAssociate;
    uint32_t mNumExports;
    const wchar_t* *mExports;
};

struct DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    const wchar_t* mSubobjectToAssociate;
    uint32_t mNumExports;
    const wchar_t* *mExports;
};

enum HIT_GROUP_TYPE : uint32_t {
    HIT_GROUP_TYPE_TRIANGLES	= 0,
    HIT_GROUP_TYPE_PROCEDURAL_PRIMITIVE	= 0x1
};

struct HIT_GROUP_DESC {
    const wchar_t* mHitGroupExport;
    HIT_GROUP_TYPE mType;
    const wchar_t* mAnyHitShaderImport;
    const wchar_t* mClosestHitShaderImport;
    const wchar_t* mIntersectionShaderImport;
};

struct RAYTRACING_SHADER_CONFIG {
    uint32_t mMaxPayloadSizeInBytes;
    uint32_t mMaxAttributeSizeInBytes;
};

struct RAYTRACING_PIPELINE_CONFIG {
    uint32_t mMaxTraceRecursionDepth;
};

enum STATE_OBJECT_TYPE : uint32_t {
    STATE_OBJECT_TYPE_COLLECTION	= 0,
    STATE_OBJECT_TYPE_RAYTRACING_PIPELINE	= 3
};

struct STATE_OBJECT_DESC {
    STATE_OBJECT_TYPE mType;
    uint32_t mNumSubobjects;
    const STATE_SUBOBJECT *mSubobjects;
};

enum RAYTRACING_GEOMETRY_FLAGS : uint32_t {
    RAYTRACING_GEOMETRY_FLAG_NONE	= 0,
    RAYTRACING_GEOMETRY_FLAG_OPAQUE	= 0x1,
    RAYTRACING_GEOMETRY_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION	= 0x2
};

enum RAYTRACING_GEOMETRY_TYPE : uint32_t {
    RAYTRACING_GEOMETRY_TYPE_TRIANGLES	= 0,
    RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS	= ( RAYTRACING_GEOMETRY_TYPE_TRIANGLES + 1 )
};

enum RAYTRACING_INSTANCE_FLAGS : uint32_t {
    RAYTRACING_INSTANCE_FLAG_NONE	= 0,
    RAYTRACING_INSTANCE_FLAG_TRIANGLE_CULL_DISABLE	= 0x1,
    RAYTRACING_INSTANCE_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE	= 0x2,
    RAYTRACING_INSTANCE_FLAG_FORCE_OPAQUE	= 0x4,
    RAYTRACING_INSTANCE_FLAG_FORCE_NON_OPAQUE	= 0x8
};

struct GPU_VIRTUAL_ADDRESS_AND_STRIDE {
    GPU_VIRTUAL_ADDRESS mStartAddress;
    uint64_t mStrideInBytes;
};

struct GPU_VIRTUAL_ADDRESS_RANGE {
    GPU_VIRTUAL_ADDRESS mStartAddress;
    uint64_t mSizeInBytes;
};

struct GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
    GPU_VIRTUAL_ADDRESS mStartAddress;
    uint64_t mSizeInBytes;
    uint64_t mStrideInBytes;
};

struct RAYTRACING_GEOMETRY_TRIANGLES_DESC {
    GPU_VIRTUAL_ADDRESS mTransform3x4;
    Format mIndexFormat;
    Format mVertexFormat;
    uint32_t mIndexCount;
    uint32_t mVertexCount;
    GPU_VIRTUAL_ADDRESS mIndexBuffer;
    GPU_VIRTUAL_ADDRESS_AND_STRIDE mVertexBuffer;
};

struct RAYTRACING_AABB {
    float mMinX;
    float mMinY;
    float mMinZ;
    float mMaxX;
    float mMaxY;
    float mMaxZ;
};

struct RAYTRACING_GEOMETRY_AABBS_DESC {
    uint64_t mAABBCount;
    GPU_VIRTUAL_ADDRESS_AND_STRIDE mAABBs;
};

enum RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS : uint32_t {
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE	= 0,
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE	= 0x1,
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_COMPACTION	= 0x2,
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE	= 0x4,
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_BUILD	= 0x8,
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_MINIMIZE_MEMORY	= 0x10,
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE	= 0x20
};

enum RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE : uint32_t {
    RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_CLONE	= 0,
    RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_COMPACT	= 0x1,
    RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_VISUALIZATION_DECODE_FOR_TOOLS	= 0x2,
    RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_SERIALIZE	= 0x3,
    RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_DESERIALIZE	= 0x4
};

enum RAYTRACING_ACCELERATION_STRUCTURE_TYPE : uint32_t {
    RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL	= 0,
    RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL	= 0x1
};

enum ELEMENTS_LAYOUT : uint32_t {
    ELEMENTS_LAYOUT_ARRAY	= 0,
    ELEMENTS_LAYOUT_ARRAY_OF_POINTERS	= 0x1
};

enum RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE : uint32_t {
    RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE	= 0,
    RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION	= 0x1,
    RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION	= 0x2,
    RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE	= 0x3
};

struct RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {
    GPU_VIRTUAL_ADDRESS mDestBuffer;
    RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE mInfoType;
};

struct RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC {
    uint64_t mCompactedSizeInBytes;
};

struct RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC {
    uint64_t mDecodedSizeInBytes;
};

struct BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER {
    RAYTRACING_ACCELERATION_STRUCTURE_TYPE mType;
    uint32_t mNumDescs;
};

struct RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC {
    uint64_t mSerializedSizeInBytes;
    uint64_t mNumBottomLevelAccelerationStructurePointers;
};

struct alignas(4) SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {
    boost::uuids::uuid mDriverOpaqueGUID;
    uint8_t mDriverOpaqueVersioningData[ 16 ];
};

enum SERIALIZED_DATA_TYPE : uint32_t {
    SERIALIZED_DATA_RAYTRACING_ACCELERATION_STRUCTURE	= 0
};

enum DRIVER_MATCHING_IDENTIFIER_STATUS : uint32_t {
    DRIVER_MATCHING_IDENTIFIER_COMPATIBLE_WITH_DEVICE	= 0,
    DRIVER_MATCHING_IDENTIFIER_UNSUPPORTED_TYPE	= 0x1,
    DRIVER_MATCHING_IDENTIFIER_UNRECOGNIZED	= 0x2,
    DRIVER_MATCHING_IDENTIFIER_INCOMPATIBLE_VERSION	= 0x3,
    DRIVER_MATCHING_IDENTIFIER_INCOMPATIBLE_TYPE	= 0x4
};

struct SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {
    SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER mDriverMatchingIdentifier;
    uint64_t mSerializedSizeInBytesIncludingHeader;
    uint64_t mDeserializedSizeInBytes;
    uint64_t mNumBottomLevelAccelerationStructurePointersAfterHeader;
};

struct RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC {
    uint64_t mCurrentSizeInBytes;
};

struct RAYTRACING_INSTANCE_DESC {
    float mTransform[ 3 ][ 4 ];
    uint32_t mInstanceID	: 24;
    uint32_t mInstanceMask	: 8;
    uint32_t mInstanceContributionToHitGroupIndex	: 24;
    uint32_t mFlags	: 8;
    GPU_VIRTUAL_ADDRESS mAccelerationStructure;
};

struct RAYTRACING_GEOMETRY_DESC {
    RAYTRACING_GEOMETRY_TYPE mType;
    RAYTRACING_GEOMETRY_FLAGS mFlags;
    union {
        RAYTRACING_GEOMETRY_TRIANGLES_DESC mTriangles;
        RAYTRACING_GEOMETRY_AABBS_DESC mAABBs;
    };
};

struct BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
    RAYTRACING_ACCELERATION_STRUCTURE_TYPE mType;
    RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS mFlags;
    uint32_t mNumDescs;
    ELEMENTS_LAYOUT mDescsLayout;
    union {
        GPU_VIRTUAL_ADDRESS mInstanceDescs;
        const RAYTRACING_GEOMETRY_DESC *mGeometryDescs;
        const RAYTRACING_GEOMETRY_DESC *const *mpGeometryDescs;
    };
};

struct BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
    GPU_VIRTUAL_ADDRESS mDestAccelerationStructureData;
    BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS mInputs;
    GPU_VIRTUAL_ADDRESS mSourceAccelerationStructureData;
    GPU_VIRTUAL_ADDRESS mScratchAccelerationStructureData;
};

struct RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {
    uint64_t mResultDataMaxSizeInBytes;
    uint64_t mScratchDataSizeInBytes;
    uint64_t mUpdateScratchDataSizeInBytes;
};

enum RAY_FLAGS : uint32_t {
    RAY_FLAG_NONE	= 0,
    RAY_FLAG_FORCE_OPAQUE	= 0x1,
    RAY_FLAG_FORCE_NON_OPAQUE	= 0x2,
    RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH	= 0x4,
    RAY_FLAG_SKIP_CLOSEST_HIT_SHADER	= 0x8,
    RAY_FLAG_CULL_BACK_FACING_TRIANGLES	= 0x10,
    RAY_FLAG_CULL_FRONT_FACING_TRIANGLES	= 0x20,
    RAY_FLAG_CULL_OPAQUE	= 0x40,
    RAY_FLAG_CULL_NON_OPAQUE	= 0x80
};

enum HIT_KIND : uint32_t {
    HIT_KIND_TRIANGLE_FRONT_FACE	= 0xfe,
    HIT_KIND_TRIANGLE_BACK_FACE	= 0xff
};

enum AUTO_BREADCRUMB_OP : uint32_t {
    AUTO_BREADCRUMB_OP_SETMARKER	= 0,
    AUTO_BREADCRUMB_OP_BEGINEVENT	= 1,
    AUTO_BREADCRUMB_OP_ENDEVENT	= 2,
    AUTO_BREADCRUMB_OP_DRAWINSTANCED	= 3,
    AUTO_BREADCRUMB_OP_DRAWINDEXEDINSTANCED	= 4,
    AUTO_BREADCRUMB_OP_EXECUTEINDIRECT	= 5,
    AUTO_BREADCRUMB_OP_DISPATCH	= 6,
    AUTO_BREADCRUMB_OP_COPYBUFFERREGION	= 7,
    AUTO_BREADCRUMB_OP_COPYTEXTUREREGION	= 8,
    AUTO_BREADCRUMB_OP_COPYRESOURCE	= 9,
    AUTO_BREADCRUMB_OP_COPYTILES	= 10,
    AUTO_BREADCRUMB_OP_RESOLVESUBRESOURCE	= 11,
    AUTO_BREADCRUMB_OP_CLEARRENDERTARGETVIEW	= 12,
    AUTO_BREADCRUMB_OP_CLEARUNORDEREDACCESSVIEW	= 13,
    AUTO_BREADCRUMB_OP_CLEARDEPTHSTENCILVIEW	= 14,
    AUTO_BREADCRUMB_OP_RESOURCEBARRIER	= 15,
    AUTO_BREADCRUMB_OP_EXECUTEBUNDLE	= 16,
    AUTO_BREADCRUMB_OP_PRESENT	= 17,
    AUTO_BREADCRUMB_OP_RESOLVEQUERYDATA	= 18,
    AUTO_BREADCRUMB_OP_BEGINSUBMISSION	= 19,
    AUTO_BREADCRUMB_OP_ENDSUBMISSION	= 20,
    AUTO_BREADCRUMB_OP_DECODEFRAME	= 21,
    AUTO_BREADCRUMB_OP_PROCESSFRAMES	= 22,
    AUTO_BREADCRUMB_OP_ATOMICCOPYBUFFERUINT	= 23,
    AUTO_BREADCRUMB_OP_ATOMICCOPYBUFFERUINT64	= 24,
    AUTO_BREADCRUMB_OP_RESOLVESUBRESOURCEREGION	= 25,
    AUTO_BREADCRUMB_OP_WRITEBUFFERIMMEDIATE	= 26,
    AUTO_BREADCRUMB_OP_DECODEFRAME1	= 27,
    AUTO_BREADCRUMB_OP_SETPROTECTEDRESOURCESESSION	= 28,
    AUTO_BREADCRUMB_OP_DECODEFRAME2	= 29,
    AUTO_BREADCRUMB_OP_PROCESSFRAMES1	= 30,
    AUTO_BREADCRUMB_OP_BUILDRAYTRACINGACCELERATIONSTRUCTURE	= 31,
    AUTO_BREADCRUMB_OP_EMITRAYTRACINGACCELERATIONSTRUCTUREPOSTBUILDINFO	= 32,
    AUTO_BREADCRUMB_OP_COPYRAYTRACINGACCELERATIONSTRUCTURE	= 33,
    AUTO_BREADCRUMB_OP_DISPATCHRAYS	= 34,
    AUTO_BREADCRUMB_OP_INITIALIZEMETACOMMAND	= 35,
    AUTO_BREADCRUMB_OP_EXECUTEMETACOMMAND	= 36,
    AUTO_BREADCRUMB_OP_ESTIMATEMOTION	= 37,
    AUTO_BREADCRUMB_OP_RESOLVEMOTIONVECTORHEAP	= 38,
    AUTO_BREADCRUMB_OP_SETPIPELINESTATE1	= 39,
    AUTO_BREADCRUMB_OP_INITIALIZEEXTENSIONCOMMAND	= 40,
    AUTO_BREADCRUMB_OP_EXECUTEEXTENSIONCOMMAND	= 41
};

struct AUTO_BREADCRUMB_NODE {
    const char *mCommandListDebugNameA;
    const wchar_t *mCommandListDebugNameW;
    const char *mCommandQueueDebugNameA;
    const wchar_t *mCommandQueueDebugNameW;
    void *mCommandList;
    void *mCommandQueue;
    uint32_t mBreadcrumbCount;
    const uint32_t *mLastBreadcrumbValue;
    const AUTO_BREADCRUMB_OP *mCommandHistory;
    const struct AUTO_BREADCRUMB_NODE *mNext;
};

enum DRED_VERSION : uint32_t {
    DRED_VERSION_1_0	= 0x1,
    DRED_VERSION_1_1	= 0x2
};

enum DRED_FLAGS : uint32_t {
    DRED_FLAG_NONE	= 0,
    DRED_FLAG_FORCE_ENABLE	= 1,
    DRED_FLAG_DISABLE_AUTOBREADCRUMBS	= 2
};

enum DRED_ENABLEMENT : uint32_t {
    DRED_ENABLEMENT_SYSTEM_CONTROLLED	= 0,
    DRED_ENABLEMENT_FORCED_OFF	= 1,
    DRED_ENABLEMENT_FORCED_ON	= 2
};

struct DEVICE_REMOVED_EXTENDED_DATA {
    DRED_FLAGS mFlags;
    AUTO_BREADCRUMB_NODE *mHeadAutoBreadcrumbNode;
};

enum DRED_ALLOCATION_TYPE : uint32_t {
    DRED_ALLOCATION_TYPE_COMMAND_QUEUE	= 19,
    DRED_ALLOCATION_TYPE_COMMAND_ALLOCATOR	= 20,
    DRED_ALLOCATION_TYPE_PIPELINE_STATE	= 21,
    DRED_ALLOCATION_TYPE_COMMAND_LIST	= 22,
    DRED_ALLOCATION_TYPE_FENCE	= 23,
    DRED_ALLOCATION_TYPE_DESCRIPTOR_HEAP	= 24,
    DRED_ALLOCATION_TYPE_HEAP	= 25,
    DRED_ALLOCATION_TYPE_QUERY_HEAP	= 27,
    DRED_ALLOCATION_TYPE_COMMAND_SIGNATURE	= 28,
    DRED_ALLOCATION_TYPE_PIPELINE_LIBRARY	= 29,
    DRED_ALLOCATION_TYPE_VIDEO_DECODER	= 30,
    DRED_ALLOCATION_TYPE_VIDEO_PROCESSOR	= 32,
    DRED_ALLOCATION_TYPE_RESOURCE	= 34,
    DRED_ALLOCATION_TYPE_PASS	= 35,
    DRED_ALLOCATION_TYPE_CRYPTOSESSION	= 36,
    DRED_ALLOCATION_TYPE_CRYPTOSESSIONPOLICY	= 37,
    DRED_ALLOCATION_TYPE_PROTECTEDRESOURCESESSION	= 38,
    DRED_ALLOCATION_TYPE_VIDEO_DECODER_HEAP	= 39,
    DRED_ALLOCATION_TYPE_COMMAND_POOL	= 40,
    DRED_ALLOCATION_TYPE_COMMAND_RECORDER	= 41,
    DRED_ALLOCATION_TYPE_STATE_OBJECT	= 42,
    DRED_ALLOCATION_TYPE_METACOMMAND	= 43,
    DRED_ALLOCATION_TYPE_SCHEDULINGGROUP	= 44,
    DRED_ALLOCATION_TYPE_VIDEO_MOTION_ESTIMATOR	= 45,
    DRED_ALLOCATION_TYPE_VIDEO_MOTION_VECTOR_HEAP	= 46,
    DRED_ALLOCATION_TYPE_VIDEO_EXTENSION_COMMAND	= 47,
    DRED_ALLOCATION_TYPE_INVALID	= 0xffffffff
};

struct DRED_ALLOCATION_NODE {
    const char *ObjectNameA;
    const wchar_t *ObjectNameW;
    DRED_ALLOCATION_TYPE mAllocationType;
    const struct DRED_ALLOCATION_NODE *mNext;
};

struct DRED_AUTO_BREADCRUMBS_OUTPUT {
    const AUTO_BREADCRUMB_NODE *mHeadAutoBreadcrumbNode;
};

struct DRED_PAGE_FAULT_OUTPUT {
    GPU_VIRTUAL_ADDRESS mPageFaultVA;
    const DRED_ALLOCATION_NODE *mHeadExistingAllocationNode;
    const DRED_ALLOCATION_NODE *mHeadRecentFreedAllocationNode;
};

struct DEVICE_REMOVED_EXTENDED_DATA1 {
    HRESULT mDeviceRemovedReason;
    DRED_AUTO_BREADCRUMBS_OUTPUT mAutoBreadcrumbsOutput;
    DRED_PAGE_FAULT_OUTPUT mPageFaultOutput;
};

struct VERSIONED_DEVICE_REMOVED_EXTENDED_DATA {
    DRED_VERSION mVersion;
    union {
        DEVICE_REMOVED_EXTENDED_DATA mDred_1_0;
        DEVICE_REMOVED_EXTENDED_DATA1 mDred_1_1;
    };
};

enum BACKGROUND_PROCESSING_MODE : uint32_t {
    BACKGROUND_PROCESSING_MODE_ALLOWED	= 0,
    BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS	= ( BACKGROUND_PROCESSING_MODE_ALLOWED + 1 ) ,
    BACKGROUND_PROCESSING_MODE_DISABLE_BACKGROUND_WORK	= ( BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS + 1 ) ,
    BACKGROUND_PROCESSING_MODE_DISABLE_PROFILING_BY_SYSTEM	= ( BACKGROUND_PROCESSING_MODE_DISABLE_BACKGROUND_WORK + 1 )
};

enum MEASUREMENTS_ACTION : uint32_t {
    MEASUREMENTS_ACTION_KEEP_ALL	= 0,
    MEASUREMENTS_ACTION_COMMIT_RESULTS	= ( MEASUREMENTS_ACTION_KEEP_ALL + 1 ) ,
    MEASUREMENTS_ACTION_COMMIT_RESULTS_HIGH_PRIORITY	= ( MEASUREMENTS_ACTION_COMMIT_RESULTS + 1 ) ,
    MEASUREMENTS_ACTION_DISCARD_PREVIOUS	= ( MEASUREMENTS_ACTION_COMMIT_RESULTS_HIGH_PRIORITY + 1 )
};

enum RENDER_PASS_BEGINNING_ACCESS_TYPE : uint32_t {
    RENDER_PASS_BEGINNING_ACCESS_TYPE_DISCARD	= 0,
    RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE	= ( RENDER_PASS_BEGINNING_ACCESS_TYPE_DISCARD + 1 ) ,
    RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR	= ( RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE + 1 ) ,
    RENDER_PASS_BEGINNING_ACCESS_TYPE_NO_ACCESS	= ( RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR + 1 )
};

struct RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS {
    CLEAR_VALUE mClearValue;
};

struct RENDER_PASS_BEGINNING_ACCESS {
    RENDER_PASS_BEGINNING_ACCESS_TYPE mType;
    union {
        RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS mClear;
    };
};

enum RENDER_PASS_ENDING_ACCESS_TYPE : uint32_t {
    RENDER_PASS_ENDING_ACCESS_TYPE_DISCARD	= 0,
    RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE	= ( RENDER_PASS_ENDING_ACCESS_TYPE_DISCARD + 1 ) ,
    RENDER_PASS_ENDING_ACCESS_TYPE_RESOLVE	= ( RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE + 1 ) ,
    RENDER_PASS_ENDING_ACCESS_TYPE_NO_ACCESS	= ( RENDER_PASS_ENDING_ACCESS_TYPE_RESOLVE + 1 )
};

struct RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {
    uint32_t mSrcSubresource;
    uint32_t mDstSubresource;
    uint32_t mDstX;
    uint32_t mDstY;
    RECT mSrcRect;
};

struct RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {
    void *mSrcResource;
    void *mDstResource;
    uint32_t mSubresourceCount;
    const RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS *mSubresourceParameters;
    Format mFormat;
    RESOLVE_MODE mResolveMode;
    Bool mPreserveResolveSource;
};

struct RENDER_PASS_ENDING_ACCESS {
    RENDER_PASS_ENDING_ACCESS_TYPE mType;
    union {
        RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS mResolve;
    };
};

struct RENDER_PASS_RENDER_TARGET_DESC {
    CPU_DESCRIPTOR_HANDLE mcpuDescriptor;
    RENDER_PASS_BEGINNING_ACCESS mBeginningAccess;
    RENDER_PASS_ENDING_ACCESS mEndingAccess;
};

struct RENDER_PASS_DEPTH_STENCIL_DESC {
    CPU_DESCRIPTOR_HANDLE mcpuDescriptor;
    RENDER_PASS_BEGINNING_ACCESS mDepthBeginningAccess;
    RENDER_PASS_BEGINNING_ACCESS mStencilBeginningAccess;
    RENDER_PASS_ENDING_ACCESS mDepthEndingAccess;
    RENDER_PASS_ENDING_ACCESS mStencilEndingAccess;
};

enum RENDER_PASS_FLAGS : uint32_t {
    RENDER_PASS_FLAG_NONE	= 0,
    RENDER_PASS_FLAG_ALLOW_UAV_WRITES	= 0x1,
    RENDER_PASS_FLAG_SUSPENDING_PASS	= 0x2,
    RENDER_PASS_FLAG_RESUMING_PASS	= 0x4
};

struct DISPATCH_RAYS_DESC {
    GPU_VIRTUAL_ADDRESS_RANGE mRayGenerationShaderRecord;
    GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE mMissShaderTable;
    GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE mHitGroupTable;
    GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE mCallableShaderTable;
    uint32_t mWidth;
    uint32_t mHeight;
    uint32_t mDepth;
};

struct SUBRESOURCE_DATA {
    const void *mData;
    int64_t mRowPitch;
    int64_t mSlicePitch;
};

struct MEMCPY_DEST {
    void *mData;
    size_t mRowPitch;
    size_t mSlicePitch;
};

enum AXIS_SHADING_RATE : uint32_t {
    AXIS_SHADING_RATE_1X	= 0,
    AXIS_SHADING_RATE_2X	= 0x1,
    AXIS_SHADING_RATE_4X	= 0x2
};

enum SHADING_RATE : uint32_t {
    SHADING_RATE_1X1	= 0,
    SHADING_RATE_1X2	= 0x1,
    SHADING_RATE_2X1	= 0x4,
    SHADING_RATE_2X2	= 0x5,
    SHADING_RATE_2X4	= 0x6,
    SHADING_RATE_4X2	= 0x9,
    SHADING_RATE_4X4	= 0xa
};

enum SHADING_RATE_COMBINER : uint32_t {
    SHADING_RATE_COMBINER_PASSTHROUGH	= 0,
    SHADING_RATE_COMBINER_OVERRIDE	= 1,
    SHADING_RATE_COMBINER_MIN	= 2,
    SHADING_RATE_COMBINER_MAX	= 3,
    SHADING_RATE_COMBINER_SUM	= 4
};

struct LargeWidth {
    uint64_t mValue = 0;
};

struct Width {
    uint32_t mValue = 0;
};

struct Height {
    uint32_t mValue = 0;
};

struct Immediate_ {} static constexpr Immediate;
struct TiledImmediate_ {} static constexpr TiledImmediate;
struct TiledDeferred_ {} static constexpr TiledDeferred;

using GpuArch = std::variant<Immediate_, TiledImmediate_, TiledDeferred_>;

struct Direct3D_ {} static constexpr Direct3D;
struct Vulkan_ {} static constexpr Vulkan;
struct Metal_ {} static constexpr Metal;
struct OpenGL_ {} static constexpr OpenGL;

using API = std::variant<Direct3D_, Vulkan_, Metal_>;

struct BINORMAL_ {} static constexpr BINORMAL;
inline bool operator==(const BINORMAL_&, const BINORMAL_&) noexcept { return true; }
inline bool operator!=(const BINORMAL_&, const BINORMAL_&) noexcept { return false; }
struct BLENDINDICES_ {} static constexpr BLENDINDICES;
inline bool operator==(const BLENDINDICES_&, const BLENDINDICES_&) noexcept { return true; }
inline bool operator!=(const BLENDINDICES_&, const BLENDINDICES_&) noexcept { return false; }
struct BLENDWEIGHT_ {} static constexpr BLENDWEIGHT;
inline bool operator==(const BLENDWEIGHT_&, const BLENDWEIGHT_&) noexcept { return true; }
inline bool operator!=(const BLENDWEIGHT_&, const BLENDWEIGHT_&) noexcept { return false; }
struct NORMAL_ {} static constexpr NORMAL;
inline bool operator==(const NORMAL_&, const NORMAL_&) noexcept { return true; }
inline bool operator!=(const NORMAL_&, const NORMAL_&) noexcept { return false; }
struct POSITIONT_ {} static constexpr POSITIONT;
inline bool operator==(const POSITIONT_&, const POSITIONT_&) noexcept { return true; }
inline bool operator!=(const POSITIONT_&, const POSITIONT_&) noexcept { return false; }
struct PSIZE_ {} static constexpr PSIZE;
inline bool operator==(const PSIZE_&, const PSIZE_&) noexcept { return true; }
inline bool operator!=(const PSIZE_&, const PSIZE_&) noexcept { return false; }
struct TANGENT_ {} static constexpr TANGENT;
inline bool operator==(const TANGENT_&, const TANGENT_&) noexcept { return true; }
inline bool operator!=(const TANGENT_&, const TANGENT_&) noexcept { return false; }
struct TEXCOORD_ {} static constexpr TEXCOORD;
inline bool operator==(const TEXCOORD_&, const TEXCOORD_&) noexcept { return true; }
inline bool operator!=(const TEXCOORD_&, const TEXCOORD_&) noexcept { return false; }
struct SV_ClipDistance_ {} static constexpr SV_ClipDistance;
inline bool operator==(const SV_ClipDistance_&, const SV_ClipDistance_&) noexcept { return true; }
inline bool operator!=(const SV_ClipDistance_&, const SV_ClipDistance_&) noexcept { return false; }
struct SV_CullDistance_ {} static constexpr SV_CullDistance;
inline bool operator==(const SV_CullDistance_&, const SV_CullDistance_&) noexcept { return true; }
inline bool operator!=(const SV_CullDistance_&, const SV_CullDistance_&) noexcept { return false; }
struct SV_Coverage_ {} static constexpr SV_Coverage;
inline bool operator==(const SV_Coverage_&, const SV_Coverage_&) noexcept { return true; }
inline bool operator!=(const SV_Coverage_&, const SV_Coverage_&) noexcept { return false; }
struct SV_Depth_ {} static constexpr SV_Depth;
inline bool operator==(const SV_Depth_&, const SV_Depth_&) noexcept { return true; }
inline bool operator!=(const SV_Depth_&, const SV_Depth_&) noexcept { return false; }
struct SV_DepthGreaterEqual_ {} static constexpr SV_DepthGreaterEqual;
inline bool operator==(const SV_DepthGreaterEqual_&, const SV_DepthGreaterEqual_&) noexcept { return true; }
inline bool operator!=(const SV_DepthGreaterEqual_&, const SV_DepthGreaterEqual_&) noexcept { return false; }
struct SV_DepthLessEqual_ {} static constexpr SV_DepthLessEqual;
inline bool operator==(const SV_DepthLessEqual_&, const SV_DepthLessEqual_&) noexcept { return true; }
inline bool operator!=(const SV_DepthLessEqual_&, const SV_DepthLessEqual_&) noexcept { return false; }
struct SV_DispatchThreadID_ {} static constexpr SV_DispatchThreadID;
inline bool operator==(const SV_DispatchThreadID_&, const SV_DispatchThreadID_&) noexcept { return true; }
inline bool operator!=(const SV_DispatchThreadID_&, const SV_DispatchThreadID_&) noexcept { return false; }
struct SV_DomainLocation_ {} static constexpr SV_DomainLocation;
inline bool operator==(const SV_DomainLocation_&, const SV_DomainLocation_&) noexcept { return true; }
inline bool operator!=(const SV_DomainLocation_&, const SV_DomainLocation_&) noexcept { return false; }
struct SV_GroupID_ {} static constexpr SV_GroupID;
inline bool operator==(const SV_GroupID_&, const SV_GroupID_&) noexcept { return true; }
inline bool operator!=(const SV_GroupID_&, const SV_GroupID_&) noexcept { return false; }
struct SV_GroupIndex_ {} static constexpr SV_GroupIndex;
inline bool operator==(const SV_GroupIndex_&, const SV_GroupIndex_&) noexcept { return true; }
inline bool operator!=(const SV_GroupIndex_&, const SV_GroupIndex_&) noexcept { return false; }
struct SV_GroupThreadID_ {} static constexpr SV_GroupThreadID;
inline bool operator==(const SV_GroupThreadID_&, const SV_GroupThreadID_&) noexcept { return true; }
inline bool operator!=(const SV_GroupThreadID_&, const SV_GroupThreadID_&) noexcept { return false; }
struct SV_GSInstanceID_ {} static constexpr SV_GSInstanceID;
inline bool operator==(const SV_GSInstanceID_&, const SV_GSInstanceID_&) noexcept { return true; }
inline bool operator!=(const SV_GSInstanceID_&, const SV_GSInstanceID_&) noexcept { return false; }
struct SV_InnerCoverage_ {} static constexpr SV_InnerCoverage;
inline bool operator==(const SV_InnerCoverage_&, const SV_InnerCoverage_&) noexcept { return true; }
inline bool operator!=(const SV_InnerCoverage_&, const SV_InnerCoverage_&) noexcept { return false; }
struct SV_InsideTessFactor_ {} static constexpr SV_InsideTessFactor;
inline bool operator==(const SV_InsideTessFactor_&, const SV_InsideTessFactor_&) noexcept { return true; }
inline bool operator!=(const SV_InsideTessFactor_&, const SV_InsideTessFactor_&) noexcept { return false; }
struct SV_InstanceID_ {} static constexpr SV_InstanceID;
inline bool operator==(const SV_InstanceID_&, const SV_InstanceID_&) noexcept { return true; }
inline bool operator!=(const SV_InstanceID_&, const SV_InstanceID_&) noexcept { return false; }
struct SV_IsFrontFace_ {} static constexpr SV_IsFrontFace;
inline bool operator==(const SV_IsFrontFace_&, const SV_IsFrontFace_&) noexcept { return true; }
inline bool operator!=(const SV_IsFrontFace_&, const SV_IsFrontFace_&) noexcept { return false; }
struct SV_OutputControlPointID_ {} static constexpr SV_OutputControlPointID;
inline bool operator==(const SV_OutputControlPointID_&, const SV_OutputControlPointID_&) noexcept { return true; }
inline bool operator!=(const SV_OutputControlPointID_&, const SV_OutputControlPointID_&) noexcept { return false; }
struct SV_Position_ {} static constexpr SV_Position;
inline bool operator==(const SV_Position_&, const SV_Position_&) noexcept { return true; }
inline bool operator!=(const SV_Position_&, const SV_Position_&) noexcept { return false; }
struct SV_PrimitiveID_ {} static constexpr SV_PrimitiveID;
inline bool operator==(const SV_PrimitiveID_&, const SV_PrimitiveID_&) noexcept { return true; }
inline bool operator!=(const SV_PrimitiveID_&, const SV_PrimitiveID_&) noexcept { return false; }
struct SV_RenderTargetArrayIndex_ {} static constexpr SV_RenderTargetArrayIndex;
inline bool operator==(const SV_RenderTargetArrayIndex_&, const SV_RenderTargetArrayIndex_&) noexcept { return true; }
inline bool operator!=(const SV_RenderTargetArrayIndex_&, const SV_RenderTargetArrayIndex_&) noexcept { return false; }
struct SV_SampleIndex_ {} static constexpr SV_SampleIndex;
inline bool operator==(const SV_SampleIndex_&, const SV_SampleIndex_&) noexcept { return true; }
inline bool operator!=(const SV_SampleIndex_&, const SV_SampleIndex_&) noexcept { return false; }
struct SV_StencilRef_ {} static constexpr SV_StencilRef;
inline bool operator==(const SV_StencilRef_&, const SV_StencilRef_&) noexcept { return true; }
inline bool operator!=(const SV_StencilRef_&, const SV_StencilRef_&) noexcept { return false; }
struct SV_Target_ {} static constexpr SV_Target;
inline bool operator==(const SV_Target_&, const SV_Target_&) noexcept { return true; }
inline bool operator!=(const SV_Target_&, const SV_Target_&) noexcept { return false; }
struct SV_TessFactor_ {} static constexpr SV_TessFactor;
inline bool operator==(const SV_TessFactor_&, const SV_TessFactor_&) noexcept { return true; }
inline bool operator!=(const SV_TessFactor_&, const SV_TessFactor_&) noexcept { return false; }
struct SV_VertexID_ {} static constexpr SV_VertexID;
inline bool operator==(const SV_VertexID_&, const SV_VertexID_&) noexcept { return true; }
inline bool operator!=(const SV_VertexID_&, const SV_VertexID_&) noexcept { return false; }
struct SV_ViewportArrayIndex_ {} static constexpr SV_ViewportArrayIndex;
inline bool operator==(const SV_ViewportArrayIndex_&, const SV_ViewportArrayIndex_&) noexcept { return true; }
inline bool operator!=(const SV_ViewportArrayIndex_&, const SV_ViewportArrayIndex_&) noexcept { return false; }

using VertexElementType = std::variant<BINORMAL_, BLENDINDICES_, BLENDWEIGHT_, NORMAL_, POSITIONT_, PSIZE_, TANGENT_, TEXCOORD_, SV_Position_, SV_Target_>;

inline bool operator<(const VertexElementType& lhs, const VertexElementType& rhs) noexcept {
    return lhs.index() < rhs.index();
}
using SemanticType = std::variant<std::monostate, BINORMAL_, BLENDINDICES_, BLENDWEIGHT_, NORMAL_, POSITIONT_, PSIZE_, TANGENT_, TEXCOORD_, SV_ClipDistance_, SV_CullDistance_, SV_Coverage_, SV_Depth_, SV_DepthGreaterEqual_, SV_DepthLessEqual_, SV_DispatchThreadID_, SV_DomainLocation_, SV_GroupID_, SV_GroupIndex_, SV_GroupThreadID_, SV_GSInstanceID_, SV_InnerCoverage_, SV_InsideTessFactor_, SV_InstanceID_, SV_IsFrontFace_, SV_OutputControlPointID_, SV_Position_, SV_PrimitiveID_, SV_RenderTargetArrayIndex_, SV_SampleIndex_, SV_StencilRef_, SV_Target_, SV_TessFactor_, SV_VertexID_, SV_ViewportArrayIndex_>;

inline bool operator<(const SemanticType& lhs, const SemanticType& rhs) noexcept {
    return lhs.index() < rhs.index();
}

struct CBV_ {} static constexpr CBV;
inline bool operator==(const CBV_&, const CBV_&) noexcept { return true; }
inline bool operator!=(const CBV_&, const CBV_&) noexcept { return false; }
inline bool operator<(const CBV_&, const CBV_&) noexcept { return false; }
struct UAV_ {} static constexpr UAV;
inline bool operator==(const UAV_&, const UAV_&) noexcept { return true; }
inline bool operator!=(const UAV_&, const UAV_&) noexcept { return false; }
inline bool operator<(const UAV_&, const UAV_&) noexcept { return false; }
struct SRV_ {} static constexpr SRV;
inline bool operator==(const SRV_&, const SRV_&) noexcept { return true; }
inline bool operator!=(const SRV_&, const SRV_&) noexcept { return false; }
inline bool operator<(const SRV_&, const SRV_&) noexcept { return false; }
struct SSV_ {} static constexpr SSV;
inline bool operator==(const SSV_&, const SSV_&) noexcept { return true; }
inline bool operator!=(const SSV_&, const SSV_&) noexcept { return false; }
inline bool operator<(const SSV_&, const SSV_&) noexcept { return false; }
struct RTV_ {} static constexpr RTV;
inline bool operator==(const RTV_&, const RTV_&) noexcept { return true; }
inline bool operator!=(const RTV_&, const RTV_&) noexcept { return false; }
inline bool operator<(const RTV_&, const RTV_&) noexcept { return false; }
struct DSV_ {} static constexpr DSV;
inline bool operator==(const DSV_&, const DSV_&) noexcept { return true; }
inline bool operator!=(const DSV_&, const DSV_&) noexcept { return false; }
inline bool operator<(const DSV_&, const DSV_&) noexcept { return false; }
struct IBV_ {} static constexpr IBV;
inline bool operator==(const IBV_&, const IBV_&) noexcept { return true; }
inline bool operator!=(const IBV_&, const IBV_&) noexcept { return false; }
inline bool operator<(const IBV_&, const IBV_&) noexcept { return false; }
struct VBV_ {} static constexpr VBV;
inline bool operator==(const VBV_&, const VBV_&) noexcept { return true; }
inline bool operator!=(const VBV_&, const VBV_&) noexcept { return false; }
inline bool operator<(const VBV_&, const VBV_&) noexcept { return false; }
struct SOV_ {} static constexpr SOV;
inline bool operator==(const SOV_&, const SOV_&) noexcept { return true; }
inline bool operator!=(const SOV_&, const SOV_&) noexcept { return false; }
inline bool operator<(const SOV_&, const SOV_&) noexcept { return false; }
struct Table_ {} static constexpr Table;
struct Constants_ {} static constexpr Constants;

using RootParameterType = std::variant<Constants_, CBV_, UAV_, SRV_, Table_, SSV_>;

inline bool operator<(const RootParameterType& lhs, const RootParameterType& rhs) noexcept {
    return lhs.index() < rhs.index();
}

inline bool operator==(const RootParameterType& lhs, const RootParameterType& rhs) noexcept {
    return lhs.index() == rhs.index();
}

inline bool operator!=(const RootParameterType& lhs, const RootParameterType& rhs) noexcept {
    return !(lhs == rhs);
}
using DescriptorType = std::variant<CBV_, UAV_, SRV_, SSV_>;

inline bool operator<(const DescriptorType& lhs, const DescriptorType& rhs) noexcept {
    return lhs.index() < rhs.index();
}

inline bool operator==(const DescriptorType& lhs, const DescriptorType& rhs) noexcept {
    return lhs.index() == rhs.index();
}

inline bool operator!=(const DescriptorType& lhs, const DescriptorType& rhs) noexcept {
    return !(lhs == rhs);
}

struct OM_ {} static constexpr OM;
struct PS_ {} static constexpr PS;
struct GS_ {} static constexpr GS;
struct DS_ {} static constexpr DS;
struct TS_ {} static constexpr TS;
struct HS_ {} static constexpr HS;
struct VS_ {} static constexpr VS;
struct CS_ {} static constexpr CS;

using ShaderStageType = std::variant<OM_, PS_, GS_, DS_, TS_, HS_, VS_, CS_>;

inline bool operator<(const ShaderStageType& lhs, const ShaderStageType& rhs) noexcept {
    return lhs.index() < rhs.index();
}

inline bool operator==(const ShaderStageType& lhs, const ShaderStageType& rhs) noexcept {
    return lhs.index() == rhs.index();
}

inline bool operator!=(const ShaderStageType& lhs, const ShaderStageType& rhs) noexcept {
    return !(lhs == rhs);
}
using ShaderVisibilityType = std::variant<std::monostate, PS_, GS_, DS_, HS_, VS_>;

inline bool operator<(const ShaderVisibilityType& lhs, const ShaderVisibilityType& rhs) noexcept {
    return lhs.index() < rhs.index();
}

inline bool operator==(const ShaderVisibilityType& lhs, const ShaderVisibilityType& rhs) noexcept {
    return lhs.index() == rhs.index();
}

inline bool operator!=(const ShaderVisibilityType& lhs, const ShaderVisibilityType& rhs) noexcept {
    return !(lhs == rhs);
}

enum UpdateEnum : uint32_t {
    PerInstance = 0,
    PerBatch = 1,
    PerPass = 2,
    PerFrame = 3,
    UpdateCount = 4,
};

struct Dynamic_ {} static constexpr Dynamic;
struct Persistent_ {} static constexpr Persistent;

using Persistency = std::variant<Dynamic_, Persistent_>;

inline bool operator<(const Persistency& lhs, const Persistency& rhs) noexcept {
    return lhs.index() < rhs.index();
}

inline bool operator==(const Persistency& lhs, const Persistency& rhs) noexcept {
    return lhs.index() == rhs.index();
}

inline bool operator!=(const Persistency& lhs, const Persistency& rhs) noexcept {
    return !(lhs == rhs);
}

struct DescriptorIndex {
    UpdateEnum mUpdate = PerInstance;
    RootParameterType mType = Table;
    ShaderVisibilityType mVisibility;
    Persistency mPersistency;
};

inline bool operator==(const DescriptorIndex&lhs, const DescriptorIndex&rhs) noexcept {
    return
        std::forward_as_tuple(lhs.mUpdate, lhs.mType, lhs.mVisibility, lhs.mPersistency) ==
        std::forward_as_tuple(rhs.mUpdate, rhs.mType, rhs.mVisibility, rhs.mPersistency);
}
inline bool operator!=(const DescriptorIndex&lhs, const DescriptorIndex&rhs) noexcept {
    return !(lhs == rhs);
}

inline bool operator<(const DescriptorIndex&lhs, const DescriptorIndex&rhs) noexcept {
    return
        std::forward_as_tuple(lhs.mUpdate, lhs.mType, lhs.mVisibility, lhs.mPersistency) <
        std::forward_as_tuple(rhs.mUpdate, rhs.mType, rhs.mVisibility, rhs.mPersistency);
}

struct EngineSource_ {} static constexpr EngineSource;
struct RenderTargetSource_ {} static constexpr RenderTargetSource;
struct MaterialSource_ {} static constexpr MaterialSource;

using DescriptorSource = std::variant<EngineSource_, RenderTargetSource_, MaterialSource_>;

inline bool operator<(const DescriptorSource& lhs, const DescriptorSource& rhs) noexcept {
    return lhs.index() < rhs.index();
}

struct matrix_ {} static constexpr matrix;
inline bool operator==(const matrix_&, const matrix_&) noexcept { return true; }
inline bool operator!=(const matrix_&, const matrix_&) noexcept { return false; }
struct double4_ {} static constexpr double4;
inline bool operator==(const double4_&, const double4_&) noexcept { return true; }
inline bool operator!=(const double4_&, const double4_&) noexcept { return false; }
struct double3_ {} static constexpr double3;
inline bool operator==(const double3_&, const double3_&) noexcept { return true; }
inline bool operator!=(const double3_&, const double3_&) noexcept { return false; }
struct double2_ {} static constexpr double2;
inline bool operator==(const double2_&, const double2_&) noexcept { return true; }
inline bool operator!=(const double2_&, const double2_&) noexcept { return false; }
struct double1_ {} static constexpr double1;
inline bool operator==(const double1_&, const double1_&) noexcept { return true; }
inline bool operator!=(const double1_&, const double1_&) noexcept { return false; }
struct float4_ {} static constexpr float4;
inline bool operator==(const float4_&, const float4_&) noexcept { return true; }
inline bool operator!=(const float4_&, const float4_&) noexcept { return false; }
struct float3_ {} static constexpr float3;
inline bool operator==(const float3_&, const float3_&) noexcept { return true; }
inline bool operator!=(const float3_&, const float3_&) noexcept { return false; }
struct float2_ {} static constexpr float2;
inline bool operator==(const float2_&, const float2_&) noexcept { return true; }
inline bool operator!=(const float2_&, const float2_&) noexcept { return false; }
struct float1_ {} static constexpr float1;
inline bool operator==(const float1_&, const float1_&) noexcept { return true; }
inline bool operator!=(const float1_&, const float1_&) noexcept { return false; }
struct half4_ {} static constexpr half4;
inline bool operator==(const half4_&, const half4_&) noexcept { return true; }
inline bool operator!=(const half4_&, const half4_&) noexcept { return false; }
struct half3_ {} static constexpr half3;
inline bool operator==(const half3_&, const half3_&) noexcept { return true; }
inline bool operator!=(const half3_&, const half3_&) noexcept { return false; }
struct half2_ {} static constexpr half2;
inline bool operator==(const half2_&, const half2_&) noexcept { return true; }
inline bool operator!=(const half2_&, const half2_&) noexcept { return false; }
struct half1_ {} static constexpr half1;
inline bool operator==(const half1_&, const half1_&) noexcept { return true; }
inline bool operator!=(const half1_&, const half1_&) noexcept { return false; }
struct uint4_ {} static constexpr uint4;
inline bool operator==(const uint4_&, const uint4_&) noexcept { return true; }
inline bool operator!=(const uint4_&, const uint4_&) noexcept { return false; }
struct uint3_ {} static constexpr uint3;
inline bool operator==(const uint3_&, const uint3_&) noexcept { return true; }
inline bool operator!=(const uint3_&, const uint3_&) noexcept { return false; }
struct uint2_ {} static constexpr uint2;
inline bool operator==(const uint2_&, const uint2_&) noexcept { return true; }
inline bool operator!=(const uint2_&, const uint2_&) noexcept { return false; }
struct uint1_ {} static constexpr uint1;
inline bool operator==(const uint1_&, const uint1_&) noexcept { return true; }
inline bool operator!=(const uint1_&, const uint1_&) noexcept { return false; }
struct int4_ {} static constexpr int4;
inline bool operator==(const int4_&, const int4_&) noexcept { return true; }
inline bool operator!=(const int4_&, const int4_&) noexcept { return false; }
struct int3_ {} static constexpr int3;
inline bool operator==(const int3_&, const int3_&) noexcept { return true; }
inline bool operator!=(const int3_&, const int3_&) noexcept { return false; }
struct int2_ {} static constexpr int2;
inline bool operator==(const int2_&, const int2_&) noexcept { return true; }
inline bool operator!=(const int2_&, const int2_&) noexcept { return false; }
struct int1_ {} static constexpr int1;
inline bool operator==(const int1_&, const int1_&) noexcept { return true; }
inline bool operator!=(const int1_&, const int1_&) noexcept { return false; }
struct fixed4_ {} static constexpr fixed4;
inline bool operator==(const fixed4_&, const fixed4_&) noexcept { return true; }
inline bool operator!=(const fixed4_&, const fixed4_&) noexcept { return false; }
struct fixed3_ {} static constexpr fixed3;
inline bool operator==(const fixed3_&, const fixed3_&) noexcept { return true; }
inline bool operator!=(const fixed3_&, const fixed3_&) noexcept { return false; }
struct fixed2_ {} static constexpr fixed2;
inline bool operator==(const fixed2_&, const fixed2_&) noexcept { return true; }
inline bool operator!=(const fixed2_&, const fixed2_&) noexcept { return false; }
struct fixed1_ {} static constexpr fixed1;
inline bool operator==(const fixed1_&, const fixed1_&) noexcept { return true; }
inline bool operator!=(const fixed1_&, const fixed1_&) noexcept { return false; }
struct InputPatch_ {} static constexpr InputPatch;
struct OutputPatch_ {} static constexpr OutputPatch;
struct CBuffer_ {} static constexpr CBuffer;
struct Buffer_ {} static constexpr Buffer;
struct ByteAddressBuffer_ {} static constexpr ByteAddressBuffer;
struct StructuredBuffer_ {} static constexpr StructuredBuffer;
struct AppendStructuredBuffer_ {} static constexpr AppendStructuredBuffer;
struct ConsumeStructuredBuffer_ {} static constexpr ConsumeStructuredBuffer;
struct Texture1D_ {} static constexpr Texture1D;
struct Texture1DArray_ {} static constexpr Texture1DArray;
struct Texture2D_ {} static constexpr Texture2D;
struct Texture2DArray_ {} static constexpr Texture2DArray;
struct Texture2DMS_ {} static constexpr Texture2DMS;
struct Texture2DMSArray_ {} static constexpr Texture2DMSArray;
struct Texture3D_ {} static constexpr Texture3D;
struct TextureCube_ {} static constexpr TextureCube;
struct TextureCubeArray_ {} static constexpr TextureCubeArray;
struct RWBuffer_ {} static constexpr RWBuffer;
struct RWByteAddressBuffer_ {} static constexpr RWByteAddressBuffer;
struct RWStructuredBuffer_ {} static constexpr RWStructuredBuffer;
struct RWTexture1D_ {} static constexpr RWTexture1D;
struct RWTexture1DArray_ {} static constexpr RWTexture1DArray;
struct RWTexture2D_ {} static constexpr RWTexture2D;
struct RWTexture2DArray_ {} static constexpr RWTexture2DArray;
struct RWTexture3D_ {} static constexpr RWTexture3D;
struct SamplerState_ {} static constexpr SamplerState;

using AttributeType = std::variant<matrix_, float4_, uint4_, int4_, float2_, uint2_, int2_, half4_, float1_, uint1_, int1_, half2_, fixed4_, half1_, InputPatch_, OutputPatch_, CBuffer_, Buffer_, ByteAddressBuffer_, StructuredBuffer_, Texture1D_, Texture1DArray_, Texture2D_, Texture2DArray_, Texture2DMS_, Texture2DMSArray_, Texture3D_, TextureCube_, TextureCubeArray_, AppendStructuredBuffer_, ConsumeStructuredBuffer_, RWBuffer_, RWByteAddressBuffer_, RWStructuredBuffer_, RWTexture1D_, RWTexture1DArray_, RWTexture2D_, RWTexture2DArray_, RWTexture3D_, SamplerState_>;

inline bool operator<(const AttributeType& lhs, const AttributeType& rhs) noexcept {
    return lhs.index() < rhs.index();
}

inline bool operator==(const AttributeType& lhs, const AttributeType& rhs) noexcept {
    return lhs.index() == rhs.index();
}

inline bool operator!=(const AttributeType& lhs, const AttributeType& rhs) noexcept {
    return !(lhs == rhs);
}

} // namespace Render

} // namespace Graphics

} // namespace Star

#ifdef _MSC_VER
#pragma warning(pop)
#endif
